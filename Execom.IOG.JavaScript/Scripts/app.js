// Generated by CoffeeScript 1.3.3
(function() {
  var Activator, AppendableChangeSet, BPlusTreeOperationsClass, CommitDataService, IsolatedNodeProvider, ParentMapProvider, RecursiveResolutionParameters, TypeMergeRule, WorkspaceStateElement, _StaticProxyFacade,
    __hasProp = {}.hasOwnProperty,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  window.IOGSettings = {
    ObjectCacheMinimumCount: 50000,
    ObjectCacheMaximumCount: 100000
  };

  Object.prototype.equals = function(other) {
    var hasOwnProperty, key, value;
    for (key in this) {
      if (!__hasProp.call(this, key)) continue;
      value = this[key];
      if ((other != null)) {
        hasOwnProperty = other.hasOwnProperty(key);
      } else {
        hasOwnProperty = false;
      }
      if (!(other != null) || !hasOwnProperty) {
        return false;
      }
      if (typeof other[key] === 'undefined') {
        return false;
      }
    }
    for (key in this) {
      if (!__hasProp.call(this, key)) continue;
      value = this[key];
      if (this[key]) {
        switch (typeof this[key]) {
          case 'object':
            if (!this[key].equals(other[key])) {
              return false;
            }
            break;
          case 'function':
            if (typeof other[key] === 'undefined' || (key !== 'equals' && this[key].toString() !== other[key].toString())) {
              return false;
            }
            break;
          default:
            if (this[key] !== other[key]) {
              return false;
            }
        }
      } else {
        if (other[key]) {
          return false;
        }
      }
    }
    for (key in other) {
      if (!__hasProp.call(other, key)) continue;
      value = other[key];
      if (typeof this[key] === 'undefined') {
        return false;
      }
    }
    return true;
  };

  String.prototype.GetHashcode = function() {
    var charachter, hash, index, len, _i, _len;
    hash = 0;
    len = this.length;
    if (this.length === 0) {
      return hash;
    }
    for (index = _i = 0, _len = this.length; _i < _len; index = ++_i) {
      charachter = this[index];
      hash = ((hash << 5) - hash) + charachter;
      hash = hash & hash;
    }
    return hash;
  };

  ({
    /*
    mergeSort: (array, comparison) ->
      if(array.length < 2)
        return array
      middle = Math.ceil(array.length/2);
      return merge(merge_sort(array.slice(0,middle),comparison),
        merge_sort(array.slice(middle),comparison),
        comparison);
    
    # sorting two arrays where first contains keys and second contains values that corresponding
    # this will be most basic implementation, for better performance we should implement
    # some better sorting algorithm
    # to order of keys
    # <return>keys - sorted keys, values - values that are sorted in order of keys</return>
    arraysSorter: (keys, values) ->
      if keys.length != values.length
        throw "Arrays are not same size"
    
      tempArray = []
    
      for keys, index in keys
        value = values[index]
        tempArray.push({"id": key, "value": value})
    
      tempArray.sort((a, b) ->
        return a.id.compareTo(b.id)
      )
    
      rezKeys = []
      rezValues = []
    
      for element in tempArray
        rezKeys.push(element.id)
        rezValues.push(element.value)
    
      return {
        "keys": rezKeys
        "values": rezValues
      }
    */

    hasOwnProperty: function(obj, prop) {
      var proto;
      proto = obj.__proto__ || obj.constructor.prototype;
      return (__indexOf.call(obj, prop) >= 0) && (!(__indexOf.call(proto, prop) >= 0) || proto[prop] !== obj[prop]);
    }
  });

  Array.prototype.compare = function(testArray) {
    var element, i, _i, _len;
    if (this.length !== testArray.length) {
      return false;
    }
    for (i = _i = 0, _len = this.length; _i < _len; i = ++_i) {
      element = this[i];
      if (typeof element === "Array") {
        if (!element.compare(testArray[i])) {
          return false;
        }
      }
      if (element !== testArray[i]) {
        return false;
      }
    }
    return true;
  };

  window.Comparable = (function() {

    function Comparable() {}

    Comparable.prototype.compareTo = function(other) {
      throw "There is not implementation!";
    };

    return Comparable;

  })();

  String.prototype.compareTo = function(other) {
    var char, index, otherType, _i, _len;
    otherType = typeof other;
    if (otherType !== "string") {
      throw "Cannot compare this two objects!";
    }
    for (index = _i = 0, _len = this.length; _i < _len; index = ++_i) {
      char = this[index];
      if (other[index] === char) {
        continue;
      } else {
        if (other[index] < char) {
          return 1;
        } else {
          return -1;
        }
      }
    }
    return 0;
  };

  Number.prototype.compareTo = function(other) {
    var x, y;
    x = new Number(other);
    y = new Number(this);
    if (isNaN(x) || isNaN(y)) {
      throw "One of objects are not number!";
    }
    if (this.valueOf() < other.valueOf()) {
      return -1;
    } else {
      if (this.valueOf() > other.valueOf()) {
        return 1;
      }
    }
    return 0;
  };

  Number.prototype.equals = function(other) {
    var x, y;
    x = new Number(other);
    y = new Number(this);
    if (isNaN(x) || isNaN(y)) {
      throw "One of objects are not number!";
    }
    if (other.valueOf() === this.valueOf()) {
      return true;
    }
    return false;
  };

  window.ScalarName = {
    Boolean: "Boolean",
    Int32: "Int32",
    Int64: "Int64",
    Double: "Double",
    String: "String",
    Char: "Char",
    Byte: "Byte",
    DateTime: "DateTime",
    TimeSpan: "TimeSpan",
    Guid: "Guid"
  };

  window.IOGType = (function() {

    IOGType.IOG_TYPE = "iogType";

    function IOGType(id, name, isCollectionType, isDictionaryType, isInterface, isEnum, isGenericType, genericType, customAttributes, properties, interfaces, enumValues, genericArguments, isScalar) {
      this.id = id;
      this.name = name;
      this.isCollectionType = isCollectionType;
      this.isDictionaryType = isDictionaryType;
      this.isInterface = isInterface;
      this.isEnum = isEnum;
      this.isGenericType = isGenericType;
      this.genericType = genericType;
      this.customAttributes = customAttributes;
      this.properties = properties != null ? properties : [];
      this.interfaces = interfaces != null ? interfaces : [];
      this.enumValues = enumValues != null ? enumValues : [];
      this.genericArguments = genericArguments != null ? genericArguments : [];
      this.isScalar = isScalar != null ? isScalar : false;
    }

    IOGType.prototype.GetCustomAttributes = function(name) {
      var attr, attributes, rezBoolean, _i, _len, _ref;
      attributes = [];
      rezBoolean = false;
      _ref = this.customAttributes;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        attr = _ref[_i];
        if (attr.name === name) {
          rezBoolean = true;
          attributes.push(attr);
        }
      }
      return {
        result: rezBoolean,
        value: attributes
      };
    };

    IOGType.CopyConstructor = function(iogType) {
      if (iogType instanceof IOGType) {
        return new IOGType(iogType.id, iogType.name, iogType.isCollectionType, iogType.isDictionaryType, iogType.isInterface, iogType.isEnum, iogType.isGenericType, iogType.genericType, iogType.customAttributes, iogType.properties, iogType.interfaces, iogType.enumValues, iogType.GenericArguments, iogType.isScalar);
      }
    };

    IOGType.prototype.GetProperty = function(name) {
      var prop, _i, _len;
      for (_i = 0, _len = properties.length; _i < _len; _i++) {
        prop = properties[_i];
        if (prop.name === name) {
          return prop;
        }
      }
      return null;
    };

    IOGType.CreateScalar = function(type, value) {
      var tempRez;
      if (IOGType.CheckValue(type, value)) {
        return value;
      }
      if (!type.isScalar) {
        return null;
      }
      switch (type.name) {
        case ScalarName.Boolean:
          tempRez = new IOGBoolean(value);
          return tempRez;
        case ScalarName.Byte:
          tempRez = new Byte(value);
          return tempRez;
        case ScalarName.Char:
          tempRez = new Char(value);
          return tempRez;
        case ScalarName.DateTime:
          tempRez = new DateTime();
          tempRez._millis = value;
          tempRez[IOGType.IOG_TYPE] = DateTimeType;
          return tempRez;
        case ScalarName.Double:
          tempRez = new Double(value);
          return tempRez;
        case ScalarName.Guid:
          tempRez = new Guid(value);
          return tempRez;
        case ScalarName.Int32:
          tempRez = new Int32(value);
          return tempRez;
        case ScalarName.Int64:
          tempRez = new Int64(value);
          return tempRez;
        case ScalarName.String:
          tempRez = new IOGString(value);
          return tempRez;
        case ScalarName.TimeSpan:
          tempRez = new TimeSpan();
          tempRez._millis = value;
          tempRez[IOGType.IOG_TYPE] = TimeSpanType;
          return tempRez;
        default:
          throw "Type is not scalar!";
      }
    };

    IOGType.CheckValue = function(type, value) {
      if (value instanceof IOGBaseType && value.iogType.equals(type)) {
        return true;
      } else {
        return false;
      }
    };

    IOGType.FindScalar = function(type) {
      if (!type.isScalar) {
        return null;
      }
      switch (type.name) {
        case ScalarName.Boolean:
          window.BooleanType = type;
          break;
        case ScalarName.Byte:
          window.ByteType = type;
          break;
        case ScalarName.Char:
          window.CharType = type;
          break;
        case ScalarName.DateTime:
          window.DateTimeType = type;
          break;
        case ScalarName.Double:
          window.DoubleType = type;
          break;
        case ScalarName.Guid:
          window.GuidType = type;
          break;
        case ScalarName.Int32:
          window.Int32Type = type;
          break;
        case ScalarName.Int64:
          window.Int64Type = type;
          break;
        case ScalarName.String:
          window.StringType = type;
          break;
        case ScalarName.TimeSpan:
          window.TimeSpanType = type;
          break;
        default:
          throw "Type is not scalar!";
      }
    };

    IOGType.FindType = function(name) {
      var type, _i, _len, _ref;
      _ref = window.types;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        type = _ref[_i];
        if (type.name === name) {
          return type;
        }
      }
      return null;
    };

    IOGType.prototype.AddGenericArgument = function(type, clear) {
      var genericArguments;
      if ((clear != null) && clear === true) {
        genericArguments = [];
      }
      return genericArguments.push(type);
    };

    IOGType.prototype.ClearGenericArguments = function() {
      var genericArguments;
      return genericArguments = [];
    };

    IOGType.CreateCollectionWithGenericType = function(type) {
      var newCollection;
      newCollection = IOGType.CopyConstructor(window.ArrayType);
      newCollection.ClearGenericArguments();
      newCollection.genericArguments.push(type);
      return newCollection;
    };

    IOGType.CreateDictionaryWithGenericTypes = function(type1, type2) {
      var newCollection;
      newCollection = IOGType.CopyConstructor(window.DictionaryType);
      newCollection.ClearGenericArguments();
      newCollection.genericArguments.push(type1);
      newCollection.genericArguments.push(type2);
      return newCollection;
    };

    return IOGType;

  })();

  IOGType.prototype.equals = function(other) {
    var hasOwnProperty, key, value;
    for (key in this) {
      if (!__hasProp.call(this, key)) continue;
      value = this[key];
      if ((other != null)) {
        hasOwnProperty = other.hasOwnProperty(key);
      } else {
        hasOwnProperty = false;
      }
      if (!(other != null) || !hasOwnProperty) {
        return false;
      }
      if (typeof other[key] === 'undefined') {
        return false;
      }
    }
    for (key in this) {
      if (!__hasProp.call(this, key)) continue;
      value = this[key];
      if ((key != null) && key.equals("genericArguments")) {
        continue;
      }
      if (this[key]) {
        switch (typeof this[key]) {
          case 'object':
            if (!this[key].equals(other[key])) {
              return false;
            }
            break;
          case 'function':
            if (typeof other[key] === 'undefined' || (key !== 'equals' && this[key].toString() !== other[key].toString())) {
              return false;
            }
            break;
          default:
            if (this[key] !== other[key]) {
              return false;
            }
        }
      } else {
        if (other[key]) {
          return false;
        }
      }
    }
    for (key in other) {
      if (!__hasProp.call(other, key)) continue;
      value = other[key];
      if (typeof this[key] === 'undefined') {
        return false;
      }
    }
    return true;
  };

  window.PropertyNameProxy = (function() {

    function PropertyNameProxy(nameOfType, genericArgumentsName) {
      this.nameOfType = nameOfType;
      this.genericArgumentsName = genericArgumentsName != null ? genericArgumentsName : [];
    }

    return PropertyNameProxy;

  })();

  window.BooleanType = new IOGType(UUID.create(), ScalarName.Boolean, false, false, false, false, false, null, []);

  window.StringType = new IOGType(UUID.create(), ScalarName.String, false, false, false, false, false, null, []);

  window.Int32Type = new IOGType(UUID.create(), ScalarName.Int32, false, false, false, false, false, null, []);

  window.Int64Type = new IOGType(UUID.create(), ScalarName.Int64, false, false, false, false, false, null, []);

  window.DoubleType = new IOGType(UUID.create(), ScalarName.Double, false, false, false, false, false, null, []);

  window.DateTimeType = new IOGType(UUID.create(), ScalarName.DateTime, false, false, false, false, false, null, []);

  window.GuidType = new IOGType(UUID.create(), ScalarName.Guid, false, false, false, false, false, null, []);

  window.TimeSpanType = new IOGType(UUID.create(), ScalarName.TimeSpan, false, false, false, false, false, null, []);

  window.ByteType = new IOGType(UUID.create(), ScalarName.Byte, false, false, false, false, false, null, []);

  window.CharType = new IOGType(UUID.create(), ScalarName.Char, false, false, false, false, false, null, []);

  window.ArrayType = null;

  window.DictionaryType = null;

  window.RootType = null;

  window.types = [];

  /*
  types.push(BooleanType)
  types.push(StringType)
  types.push(Int32Type)
  types.push(Int64Type)
  types.push(DoubleType)
  types.push(DateTimeType)
  types.push(GuidType)
  types.push(TimeSpanType)
  types.push(ByteType)
  types.push(CharType)
  types.push(TimeSpanType)
  */


  window.IOGBaseType = (function() {

    function IOGBaseType() {}

    return IOGBaseType;

  })();

  window.IOGNumber = (function(_super) {

    __extends(IOGNumber, _super);

    function IOGNumber() {
      return IOGNumber.__super__.constructor.apply(this, arguments);
    }

    IOGNumber.NumberCompare = function(value1, value2) {
      var x, y;
      if (!(value1 instanceof IOGNumber) && !(value2 instanceof IOGNumber)) {
        throw "One of objects are not number!";
      }
      if (!value1.iogType.equals(value2.iogType)) {
        throw "One of objects are not number!";
      }
      x = new Number(value1.value);
      y = new Number(value2.value);
      if (isNaN(x) || isNaN(y)) {
        throw "One of objects are not number!";
      }
      if (x < y) {
        return -1;
      } else {
        if (x > y) {
          return 1;
        }
      }
      return 0;
    };

    IOGNumber.NumberEqual = function(value1, value2) {
      if (!(value1 instanceof IOGNumber) && !(value2 instanceof IOGNumber)) {
        throw false;
      }
      if (!value1.iogType.equals(value2.iogType)) {
        return false;
      }
      return value1.value.equals(value2.value);
    };

    return IOGNumber;

  })(IOGBaseType);

  window.Int32 = (function(_super) {

    __extends(Int32, _super);

    Int32.MAX_VALUE = 2147483647;

    Int32.MIN_VALUE = -2147483648;

    function Int32(value) {
      var x;
      x = Number(value);
      if (isNaN(x)) {
        throw "Entered value is not int32!";
      }
      if (value < Int32.MIN_VALUE || value > Int32.MAX_VALUE) {
        throw "Out of range!";
      }
      this.value = value;
      this.iogType = IOGType.FindType(ScalarName.Int32);
    }

    Int32.prototype.compareTo = function(other) {
      return IOGNumber.NumberCompare(this, other);
    };

    Int32.prototype.equals = function(other) {
      return IOGNumber.NumberEqual(this, other);
    };

    return Int32;

  })(IOGNumber);

  window.Int64 = (function(_super) {

    __extends(Int64, _super);

    Int64.MAX_VALUE = 9223372036854775807;

    Int64.MIN_VALUE = -9223372036854775808;

    function Int64(value) {
      var x;
      x = Number(value);
      if (isNaN(x)) {
        throw "Entered value is not int32!";
      }
      if (value < Int64.MIN_VALUE || value > Int64.MAX_VALUE) {
        throw "Out of range!";
      }
      this.value = value;
      this.iogType = IOGType.FindType(ScalarName.Int64);
    }

    Int64.prototype.compareTo = function(other) {
      return IOGNumber.NumberCompare(this, other);
    };

    Int64.prototype.equals = function(other) {
      return IOGNumber.NumberEqual(this, other);
    };

    return Int64;

  })(IOGNumber);

  window.Double = (function(_super) {

    __extends(Double, _super);

    Double.MAX_VALUE = 1.7976931348623157e+308;

    Double.MIN_VALUE = -1.7976931348623157e+308;

    function Double(value) {
      var x;
      x = Number(value);
      if (isNaN(x)) {
        throw "Entered value is not int32!";
      }
      if (value < Int64.MIN_VALUE || value > Int64.MAX_VALUE) {
        throw "Out of range!";
      }
      this.value = value;
      this.iogType = IOGType.FindType(ScalarName.Double);
    }

    Double.prototype.compareTo = function(other) {
      return IOGNumber.NumberCompare(this, other);
    };

    Double.prototype.equals = function(other) {
      return IOGNumber.NumberEqual(this, other);
    };

    return Double;

  })(IOGNumber);

  window.Byte = (function(_super) {

    __extends(Byte, _super);

    Byte.MAX_VALUE = 255;

    Byte.MIN_VALUE = 0;

    function Byte(value) {
      var x;
      x = Number(value);
      if (isNaN(x)) {
        throw "Entered value is not int32!";
      }
      if (value < Int64.MIN_VALUE || value > Int64.MAX_VALUE) {
        throw "Out of range!";
      }
      this.value = value;
      this.iogType = IOGType.FindType(ScalarName.Byte);
    }

    Byte.prototype.compareTo = function(other) {
      return IOGNumber.NumberCompare(this, other);
    };

    Byte.prototype.equals = function(other) {
      return IOGNumber.NumberEqual(this, other);
    };

    return Byte;

  })(IOGNumber);

  window.Char = (function(_super) {

    __extends(Char, _super);

    function Char(value) {
      if (value.length > 1) {
        throw "Char cannot have more then one charachter!";
      }
      this.value = value;
      this.iogType = IOGType.FindType(ScalarName.Char);
    }

    Char.prototype.compareTo = function(other) {
      if (!other instanceof Char) {
        throw "Type of compering type is not right!";
      }
      return this.value.compareTo(other.value);
    };

    Char.prototype.equals = function(other) {
      if (!other instanceof Char) {
        return false;
      }
      return this.value.equals(other.value);
    };

    return Char;

  })(IOGBaseType);

  window.Guid = (function(_super) {

    __extends(Guid, _super);

    function Guid(value) {
      this.value = UUID.tryParse(value);
      this.iogType = IOGType.FindType(ScalarName.Guid);
    }

    Guid.Create = function() {
      return new Guid(UUID.create());
    };

    Guid.EMPTY = new Guid(UUID.empty);

    Guid.TryParse = function(value) {
      return new Guid(UUID.tryParse(value));
    };

    Guid.Parse = function() {
      return new Guid(UUID.Parse(value));
    };

    Guid.prototype.compareTo = function(other) {
      if (!other instanceof Char) {
        throw "Type of compering type is not right!";
      }
      return this.value.compareTo(other.value);
    };

    Guid.prototype.equals = function(other) {
      if (!other instanceof Guid) {
        return false;
      }
      return this.value.equals(other.value);
    };

    return Guid;

  })(IOGBaseType);

  window.IOGString = (function(_super) {

    __extends(IOGString, _super);

    function IOGString(value) {
      this.value = value;
      this.iogType = IOGType.FindType(ScalarName.String);
    }

    IOGString.prototype.compareTo = function(other) {
      if (!other instanceof IOGString) {
        throw "Type of compering type is not right!";
      }
      return this.value.compareTo(other.value);
    };

    IOGString.prototype.equals = function(other) {
      if (!other instanceof IOGString) {
        return false;
      }
      return this.value.equals(other.value);
    };

    return IOGString;

  })(IOGBaseType);

  window.IOGBoolean = (function(_super) {

    __extends(IOGBoolean, _super);

    function IOGBoolean(value) {
      this.value = Boolean(value);
      this.iogType = IOGType.FindType(ScalarName.Boolean);
    }

    IOGBoolean.prototype.compareTo = function(other) {
      if (!other instanceof IOGBoolean) {
        throw "Type of compering type is not right!";
      }
      if (this.value) {
        if (other.value) {
          return 0;
        } else {
          return 1;
        }
      } else {
        if (other.value) {
          return -1;
        } else {
          return 0;
        }
      }
    };

    IOGBoolean.prototype.equals = function(other) {
      if (!other instanceof Boolean) {
        return false;
      }
      return this.value === other.value;
    };

    return IOGBoolean;

  })(IOGBaseType);

  TimeSpan.ZERO = new TimeSpan();

  DateTime.MIN_DATE = new DateTime();

  DateTime.MIN_DATE.span = TimeSpan.ZERO;

  window.IsolationLevel = {
    ReadOnly: 0,
    Snapshot: 1,
    Exclusive: 2
  };

  window.EdgeType = {
    Contains: 0,
    OfType: 1,
    Property: 2,
    ListItem: 3,
    RootObject: 4,
    Special: 5
  };

  window.EdgeFlags = {
    None: 0,
    Permanent: 1
  };

  window.NodeType = {
    TypesRoot: 0,
    SnapshotsRoot: 1,
    Snapshot: 2,
    Type: 3,
    Scalar: 4,
    Object: 5,
    Collection: 6,
    Dictionary: 7,
    TypeMember: 8,
    TreeInternal: 9,
    TreeLeaf: 10
  };

  window.NodeState = {
    None: 0,
    Created: 1,
    Modified: 2,
    Removed: 3
  };

  window.NodeAccess = {
    Read: 0,
    ReadWrite: 1
  };

  window.Constants = {
    TypesNodeId: new Guid("22DD35BD-071B-4429-837D-4F5D2C201580"),
    SnapshotsNodeId: new Guid("52138911-0016-4C08-A685-9487617FD664"),
    ExclusiveWriterLockId: new Guid("7EB5139E-72C2-4029-9EFD-1CD514775832"),
    NullReferenceNodeId: new Guid("FFCE2840-A5D7-4C1F-81F4-A8AC7FC61F92"),
    InstanceIdFieldName: "__instanceId__",
    PrimaryKeyIdFieldName: "__keyId__",
    TypeIdFieldName: "__typeId__",
    FacadeFieldName: "__facade__",
    ReadOnlyFieldName: "__readOnly__",
    ProxyTypeSufix: "ProxyTypeSufix",
    GeneratedAssemblyName: "IOG.RuntimeProxy",
    PropertyMemberIdSufix: "_MemberID_",
    PropertyIsScalarSufix: "_IsScalar_",
    TypeMemberPrimaryKeyId: new Guid("67B21654-1E2D-4565-A4AE-33A7E1D43AF2")
  };

  window.MemberTypes = {
    Constructor: 0,
    Event: 1,
    Field: 2,
    Method: 3,
    Property: 4,
    TypeInfo: 5,
    Custom: 6,
    NestedType: 7,
    All: 8
  };

  window.TypeConstants = {
    ID: "ID",
    Name: "Name",
    IsCollectionType: "IsCollectionType",
    IsDictionaryType: "IsDictionaryType",
    IsInterface: "IsInterface",
    IsEnum: "IsEnum",
    IsGenericType: "IsGenericType",
    CustomAttributes: "CustomAttributes",
    Interfaces: "Interfaces",
    EnumValues: "EnumValues",
    GenericArguments: "GenericArguments",
    IsScalar: "IsScalar",
    GenericType: "GenericType",
    Properties: "Properties"
  };

  window.ProperiteConstants = {
    CanRead: "CanRead",
    CanWrite: "CanWrite",
    Name: "Name",
    IsStatic: "IsStatic",
    CustomAttributes: "CustomAttributes",
    PropertyType: "PropertyType",
    DeclaringType: "DeclaringType"
  };

  window.IOGTypeConstants = {
    Collection: "Collection",
    Dictionary: "Dictionary"
  };

  window.Edge = (function() {

    function Edge(toNodeId, data) {
      this.toNodeId = toNodeId;
      this.data = data;
    }

    return Edge;

  })();

  window.EdgeData = (function() {

    function EdgeData(semantic, data, flags) {
      this.semantic = semantic;
      this.data = data;
      this.flags = flags != null ? flags : EdgeFlags.None;
    }

    EdgeData.prototype.compareTo = function(other) {
      if (!(other != null)) {
        console.log(other);
      }
      if ((other != null) && !(other.semantic != null)) {
        console.log(other.semantic);
      }
      if (this.equals(other)) {
        return 0;
      }
      if (this.semantic === EdgeType.Special) {
        if (this === EdgeDataSingleton.MIN_VALUE) {
          return -1;
        }
        if (other === EdgeDataSingleton.MIN_VALUE) {
          return 1;
        }
        if (this === EdgeDataSingleton.MAX_VALUE) {
          return 1;
        }
        if (other === EdgeDataSingleton.MAX_VALUE) {
          return -1;
        }
      }
      if (this.semantic === other.semantic) {
        if (this.data.hasOwnProperty('data') && this.data.hasOwnProperty('data')) {
          return this.data.data.compareTo(other.data.data);
        } else {
          return this.data.compareTo(other.data);
        }
      } else {
        if (this.semantic < other.semantic) {
          return -1;
        } else {
          if (this.semantic > other.semantic) {
            return 1;
          } else {
            return 0;
          }
        }
      }
    };

    return EdgeData;

  })();

  window.EdgeDataSingleton = {
    MAX_VALUE: new EdgeData(EdgeType.Special, new Guid("53F11357-62B7-430F-B446-9EC8F9702406"), EdgeFlags.None),
    MIN_VALUE: new EdgeData(EdgeType.Special, new Guid("76367091-B69D-4BDF-A643-779032AF3503"), EdgeFlags.None)
  };

  window.SortedList = (function() {

    function SortedList(array) {
      this.array = array != null ? array : [];
      this.keys = [];
    }

    SortedList.prototype.FindIndexInserting = function(key) {
      var ele, index, _i, _len, _ref;
      _ref = this.keys;
      for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
        ele = _ref[index];
        if (ele.compareTo(key) >= 0) {
          return index;
        }
      }
      return -1;
    };

    SortedList.prototype.Add = function(key, value) {
      var index;
      index = this.FindIndexInserting(key);
      if (index !== -1) {
        this.array.splice(index, 0, {
          "key": key,
          "value": value
        });
        this.keys.splice(index, 0, key);
      } else {
        this.array.push({
          "key": key,
          "value": value
        });
        this.keys.push(key);
      }
    };

    SortedList.prototype.Set = function(key, value) {
      var index;
      if (this.Contains(key)) {
        index = this.IndexOf(key);
        if (key === this.array[index].key) {
          this.array[index].value = value;
          return;
        }
        return;
      }
    };

    SortedList.prototype.Remove = function(key) {
      var index, tempArray, tempKeys;
      if (this.Contains(key)) {
        index = this.IndexOf(key);
        if (index === 0) {
          this.keys = this.keys.slice(1, this.keys.length);
          this.array = this.array.slice(1, this.array.length);
          return true;
        } else {
          if (index === this.keys.length - 1) {
            this.keys = this.keys.slice(0, this.keys.length - 1);
            this.array = this.array.slice(0, this.array.length - 1);
            return true;
          } else {
            tempKeys = this.keys.slice(0, index);
            tempArray = this.array.slice(0, index);
            this.keys = this.keys.slice(index + 1, this.keys.length);
            this.array = this.array.slice(index + 1, this.array.length);
            this.keys = tempKeys.concat(this.keys);
            this.array = tempArray.concat(this.array);
            return true;
          }
        }
      }
      return false;
    };

    SortedList.prototype.Contains = function(key) {
      var i, index, k, _i, _len, _ref;
      index = -1;
      _ref = this.keys;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        k = _ref[i];
        if (k.equals(key)) {
          index = i;
          break;
        }
      }
      if (index !== -1) {
        return true;
      } else {
        return false;
      }
    };

    SortedList.prototype.IndexOf = function(key) {
      var i, index, k, _i, _len, _ref;
      index = -1;
      _ref = this.keys;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        k = _ref[i];
        if (k.equals(key)) {
          index = i;
          return index;
        }
      }
      return index;
    };

    SortedList.prototype.Get = function(key) {
      var i, index, k, _i, _len, _ref;
      if (this.Contains(key)) {
        index = -1;
        _ref = this.keys;
        for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
          k = _ref[i];
          if (k.equals(key)) {
            index = i;
            break;
          }
        }
        if (key.equals(this.array[index].key)) {
          return this.array[index].value;
        } else {
          return null;
        }
      } else {
        return null;
      }
    };

    SortedList.prototype.Array = function() {
      var element, rez, _i, _len, _ref;
      rez = [];
      _ref = this.array;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        element = _ref[_i];
        rez.push(element.value);
      }
      return rez;
    };

    SortedList.prototype.Length = function() {
      return this.keys.length;
    };

    SortedList.prototype.Clear = function() {
      this.array = [];
      this.keys = [];
    };

    SortedList.prototype.Keys = function() {
      return this.keys;
    };

    return SortedList;

  })();

  window.Dictionary = (function() {

    function Dictionary(array) {
      this.array = array != null ? array : [];
      this.length = 0;
      this.keys = [];
    }

    Dictionary.prototype.Add = function(key, value) {
      this.array.push({
        "key": key,
        "value": value
      });
      this.keys.push(key);
      this.length = this.length + 1;
    };

    Dictionary.prototype.Set = function(key, value) {
      var index;
      if (this.Contains(key)) {
        index = this.IndexOf(key);
        if (key.equals(this.array[index].key)) {
          this.array[index].value = value;
          return;
        }
        return;
      }
    };

    Dictionary.prototype.Remove = function(key) {
      var index, tempArray, tempKeys;
      if (this.Contains(key)) {
        index = this.IndexOf(key);
        if (index === 0) {
          this.keys = this.keys.slice(1, this.keys.length);
          this.array = this.array.slice(1, this.array.length);
        } else {
          if (index === this.keys.length - 1) {
            this.keys = this.keys.slice(0, this.keys.length - 1);
            this.array = this.array.slice(0, this.array.length - 1);
          } else {
            tempKeys = this.keys.slice(0, index);
            tempArray = this.array.slice(0, index);
            this.keys = this.keys.slice(index + 1, this.keys.length);
            this.array = this.array.slice(index + 1, this.array.length);
            this.keys = tempKeys.concat(this.keys);
            this.array = tempArray.concat(this.array);
          }
        }
        this.length = this.length - 1;
        return true;
      }
      return false;
    };

    Dictionary.prototype.Contains = function(key) {
      var i, index, k, _i, _len, _ref;
      index = -1;
      _ref = this.keys;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        k = _ref[i];
        if (k.equals(key)) {
          index = i;
          break;
        }
      }
      if (index !== -1) {
        return true;
      } else {
        return false;
      }
    };

    Dictionary.prototype.IndexOf = function(key) {
      var i, index, k, _i, _len, _ref;
      index = -1;
      _ref = this.keys;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        k = _ref[i];
        if (k.equals(key)) {
          index = i;
          return index;
        }
      }
      return index;
    };

    Dictionary.prototype.Get = function(key) {
      var i, index, k, _i, _len, _ref;
      if (this.Contains(key)) {
        index = -1;
        _ref = this.keys;
        for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
          k = _ref[i];
          if (k.equals(key)) {
            index = i;
            break;
          }
        }
        if (key.equals(this.array[index].key)) {
          return this.array[index].value;
        } else {
          return null;
        }
      } else {
        return null;
      }
    };

    Dictionary.prototype.Array = function() {
      var element, rez, _i, _len, _ref;
      rez = [];
      _ref = this.array;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        element = _ref[_i];
        rez.push(element.value);
      }
      return rez;
    };

    Dictionary.prototype.Length = function() {
      return this.length;
    };

    Dictionary.prototype.Clear = function() {
      this.array = [];
      this.keys = [];
      this.length = 0;
    };

    Dictionary.prototype.Keys = function() {
      return this.keys;
    };

    return Dictionary;

  })();

  window.Node = (function() {

    function Node(nodeType, data, edges, values) {
      this.nodeType = nodeType;
      this.data = data;
      this.edges = edges != null ? edges : new SortedList();
      this.values = values != null ? values : new Dictionary();
      this.previous = Guid.EMPTY;
      this.commited = false;
    }

    Node.prototype.FindEdge = function(edgeData) {
      return this.edges.Get(edgeData);
    };

    Node.prototype.SetType = function(nodeType) {
      this.nodeType = nodeType;
    };

    Node.prototype.SetData = function(data) {
      this.data = data;
    };

    Node.prototype.AddEdge = function(edge) {
      this.edges.Add(edge.data, edge);
    };

    Node.prototype.SetEdgeToNode = function(data, toNodeId) {
      var edge;
      edge = this.edges.Get(data);
      if ((edge != null)) {
        edge.toNodeId = toNodeId;
      }
    };

    return Node;

  })();

  window.CachedReadNodeProvider = (function() {

    function CachedReadNodeProvider(parentProvider, cacheProvider) {
      this.parentProvider = parentProvider;
      this.cacheProvider = cacheProvider;
    }

    CachedReadNodeProvider.prototype.SetNode = function(identifier, node) {
      this.parentProvider.SetNode(identifier, node);
      this.cacheProvider.SetNode(identifier, node);
    };

    CachedReadNodeProvider.prototype.GetNode = function(identifier, access) {
      var node;
      node = this.cacheProvider.GetNode(identifier, access);
      if ((node != null)) {
        return node;
      } else {
        node = this.parentProvider.GetNode(identifier, access);
        this.cacheProvider.SetNode(identifier, node);
        return node;
      }
    };

    CachedReadNodeProvider.prototype.Contains = function(identifier) {
      if (this.cacheProvider.Contains(identifier)) {
        return true;
      } else {
        return this.parentProvider.Contains(identifier);
      }
    };

    CachedReadNodeProvider.prototype.Remove = function(identifier) {
      this.cacheProvider.Remove(identifier);
      this.parentProvider.Remove(identifier);
    };

    CachedReadNodeProvider.prototype.EnumerateNodes = function() {
      return this.parentProvider.EnumerateNodes();
    };

    CachedReadNodeProvider.prototype.Clear = function() {
      this.parentProvider.Clear();
      this.cacheProvider.Clear();
    };

    return CachedReadNodeProvider;

  })();

  window.DirectNodeProvider = (function() {

    function DirectNodeProvider(storage, forceUpdate) {
      this.storage = storage != null ? storage : new MemoryStorage();
      this.forceUpdate = forceUpdate != null ? forceUpdate : false;
    }

    DirectNodeProvider.prototype.SetNode = function(identifier, node) {
      return this.storage.AddOrUpdate(identifier, node);
    };

    DirectNodeProvider.prototype.GetNode = function(nodeId, access) {
      return this.storage.Value(nodeId);
    };

    DirectNodeProvider.prototype.Contains = function(identifier) {
      return this.storage.Contains(identifier);
    };

    DirectNodeProvider.prototype.Remove = function(identifier) {
      this.storage.Remove(identifier);
    };

    DirectNodeProvider.prototype.EnumerateNodes = function() {
      return this.storage.ListKeys();
    };

    DirectNodeProvider.prototype.Clear = function() {
      this.storage.Clear();
    };

    DirectNodeProvider.prototype.Length = function() {
      return this.storage.Length();
    };

    return DirectNodeProvider;

  })();

  window.MemoryStorage = (function() {

    function MemoryStorage(dictionary) {
      this.dictionary = dictionary != null ? dictionary : new Dictionary();
    }

    MemoryStorage.prototype.Remove = function(key) {
      return this.dictionary.Remove(key);
    };

    MemoryStorage.prototype.Contains = function(key) {
      return this.dictionary.Contains(key);
    };

    MemoryStorage.prototype.Value = function(key) {
      return this.dictionary.Get(key);
    };

    MemoryStorage.prototype.AddOrUpdate = function(key, value) {
      if (this.dictionary.Contains(key)) {
        this.dictionary.Set(key, value);
      } else {
        this.dictionary.Add(key, value);
      }
      return true;
    };

    MemoryStorage.prototype.ListKeys = function() {
      return this.dictionary.keys;
    };

    MemoryStorage.prototype.Values = function() {
      return this.dictionary.array.map(function(element) {
        return element.value;
      });
    };

    MemoryStorage.prototype.Clear = function() {
      this.dictionary.Clear();
    };

    MemoryStorage.prototype.Length = function() {
      return this.dictionary.Length();
    };

    return MemoryStorage;

  })();

  window.PropertyInfo = (function() {

    function PropertyInfo(canRead, canWrite, declaringType, name, propertyType, isStatic, customAttributes) {
      this.canRead = canRead;
      this.canWrite = canWrite;
      this.declaringType = declaringType;
      this.name = name;
      this.propertyType = propertyType;
      this.isStatic = isStatic;
      this.customAttributes = customAttributes != null ? customAttributes : [];
    }

    PropertyInfo.prototype.GetCustomAttributes = function(name) {
      var attr, attributes, rezBoolean, _i, _len, _ref;
      attributes = [];
      rezBoolean = false;
      _ref = this.customAttributes;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        attr = _ref[_i];
        if (attr.name === name) {
          rezBoolean = true;
          attributes.push(attr);
        }
      }
      return {
        result: rezBoolean,
        value: attributes
      };
    };

    PropertyInfo.prototype.GetPropertyType = function() {
      var type;
      type = IOGType.FindType(this.propertyType.nameOfType);
      if (UTILS.IsCollectionType(type)) {
        type = IOGType.CreateCollectionWithGenericType(this.propertyType.genericArgumentsName[0]);
      }
      if (UTILS.IsDictionaryType(type)) {
        type = IOGType.CreateDictionaryWithGenericTypes(this.propertyType.genericArgumentsName[0], this.propertyType.genericArgumentsName[1]);
      }
      return type;
    };

    return PropertyInfo;

  })();

  PropertyInfo.prototype.equals = function(other) {
    var hasOwnProperty, key, value;
    for (key in this) {
      if (!__hasProp.call(this, key)) continue;
      value = this[key];
      hasOwnProperty = other.hasOwnProperty(key);
      if (!(other != null) || !hasOwnProperty) {
        return false;
      }
      if (typeof other[key] === 'undefined') {
        return false;
      }
    }
    for (key in this) {
      if (!__hasProp.call(this, key)) continue;
      value = this[key];
      if (this[key]) {
        switch (typeof this[key]) {
          case 'object':
            if (this[key] instanceof IOGType) {
              if (this[key].id !== other[key].id) {
                return false;
              }
            } else {
              if (!this[key].equals(other[key])) {
                return false;
              }
            }
            break;
          case 'function':
            if (typeof other[key] === 'undefined' || (key !== 'equals' && this[key].toString() !== other[key].toString())) {
              return false;
            }
            break;
          default:
            if (this[key] !== other[key]) {
              return false;
            }
        }
      } else {
        if (other[key]) {
          return false;
        }
      }
    }
    for (key in other) {
      if (!__hasProp.call(other, key)) continue;
      value = other[key];
      if (typeof this[key] === 'undefined') {
        return false;
      }
    }
    return true;
  };

  window.Utils = (function() {

    function Utils() {}

    Utils.prototype.IsCollectionType = function(type) {
      if (type.isCollectionType === true) {
        return type;
      }
      return null;
    };

    Utils.prototype.IsDictionaryType = function(type) {
      if (type.isDictionaryType === true) {
        return type;
      }
      return null;
    };

    Utils.prototype.ExtractProperties = function(type, props) {
      var baseType, exist, interfaceType, p, pr, _i, _j, _k, _len, _len1, _len2, _ref, _ref1;
      _ref = type.properties;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        p = _ref[_i];
        exist = false;
        for (_j = 0, _len1 = props.length; _j < _len1; _j++) {
          pr = props[_j];
          if (pr.name === p.name) {
            exist = true;
            break;
          }
        }
        if (!exist) {
          props.push(p);
        }
      }
      _ref1 = type.interfaces;
      for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
        baseType = _ref1[_k];
        interfaceType = IOGType.FindType(baseType.name);
        if ((interfaceType != null)) {
          UTILS.ExtractProperties(interfaceType, props);
        }
      }
      return props;
    };

    Utils.prototype.GetType = function(typeName) {
      var type, _i, _len;
      if (typeName instanceof IOGType) {
        return typeName;
      }
      for (_i = 0, _len = types.length; _i < _len; _i++) {
        type = types[_i];
        if (type.name === typeName) {
          return type;
        }
      }
    };

    Utils.prototype.SetItemId = function(item, instanceId) {
      return item[Constants.InstanceIdFieldName] = instanceId;
    };

    Utils.prototype.GetItemId = function(item) {
      return item["" + Constants.InstanceIdFieldName];
    };

    Utils.prototype.HasItemId = function(item) {
      return item.hasOwnProperty(Constants.InstanceIdFieldName);
    };

    Utils.prototype.GetItemPrimaryKeyId = function(value) {
      if ((value[Constants.PrimaryKeyIdFieldName] != null)) {
        return value[Constants.PrimaryKeyIdFieldName];
      } else {
        return Guid.EMPTY;
      }
    };

    Utils.prototype.Default = function(type) {
      var val;
      if (!IsScalarType(typeId)) {
        return null;
      }
      val = null;
      if (t === BooleanType) {
        val = false;
      } else {
        if (t === DateTimeType) {
          val = DateTime.MIN_DATE;
        } else {
          if (t === TimeSpanType) {
            val = TimeSpan.ZERO;
          } else {
            if (t === Int32Type || t === Int64Type || t === DoubleType || t === ByteType) {
              val = 0;
            } else {
              if (t === StringType) {
                val = "";
              } else {
                if (t === GuidType) {
                  val = Guid.EMPTY;
                } else {
                  if (t.isEnum) {
                    val = t.enumValues[0];
                  } else {
                    return null;
                  }
                }
              }
            }
          }
        }
      }
      return val;
    };

    Utils.prototype.IsPermanentEdge = function(edge) {
      return edge.data.semantic === EdgeType.OfType || edge.toNodeId === Constants.NullReferenceNodeId || ((edge.data.flags === EdgeFlags.permanent) === EdgeFlags.permanent);
    };

    return Utils;

  })();

  window.UTILS = new Utils();

  window.TypesService = (function() {

    TypesService.IOG_TYPE = "iogType";

    function TypesService(provider) {
      this.provider = provider != null ? provider : new DirectNodeProvider();
      this.supportedScalarTypes = [];
      this.scalarTypesTable = new Dictionary();
      this.typeToIdMapping = new Dictionary();
      this.typeIdToTypeMapping = new Dictionary();
      this.collectionTypesTable = new Dictionary();
      this.dictionaryTypesTable = new Dictionary();
    }

    TypesService.prototype.AddType = function(type) {
      var baseType, collectionType, dictionaryType, id, isPermanent, isPrimaryKey, memberId, node, p, properties, tempEdge, tempEdgeData, typeId, typesNode, value, valueId, valueNode, values, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1;
      this.ValidateType(type);
      typeId = this.GetTypeId(type);
      if (typeId.equals(Guid.EMPTY)) {
        typeId = Guid.Create();
        node = new Node(NodeType.Type, this.GetTypeName(type));
        typesNode = this.provider.GetNode(Constants.TypesNodeId, NodeAccess.ReadWrite);
        tempEdgeData = new EdgeData(EdgeType.Contains, typeId);
        tempEdge = new Edge(typeId, tempEdgeData);
        typesNode.AddEdge(tempEdge);
        this.provider.SetNode(Constants.TypesNodeId, typesNode);
        this.provider.SetNode(typeId, node);
        if (type.isInterface) {
          properties = [];
          UTILS.ExtractProperties(type, properties);
          for (_i = 0, _len = properties.length; _i < _len; _i++) {
            p = properties[_i];
            isPermanent = p.GetCustomAttributes("ImmutableAttribute");
            isPrimaryKey = p.GetCustomAttributes("PrimaryKeyAttribute");
            this.AddType(p.GetPropertyType());
            memberId = this.AddTypeMember(p.name, p.GetPropertyType(), isPrimaryKey);
            node.AddEdge(new Edge(memberId, new EdgeData(EdgeType.Property, memberId, isPermanent ? EdgeFlags.Permanent : EdgeFlags.None)));
          }
          collectionType = null;
          dictionaryType = null;
          if (((collectionType = UTILS.IsCollectionType(type)) != null) && ((dictionaryType = UTILS.IsDictionaryType(type)) != null)) {
            _ref = type.interfaces;
            for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
              baseType = _ref[_j];
              id = this.AddType(baseType);
              node.AddEdge(new Edge(id, new EdgeData(EdgeType.OfType, id)));
            }
            this.provider.SetNode(typeId, node);
          } else {
            _ref1 = type.genericArguments;
            for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
              baseType = _ref1[_k];
              this.AddType(baseType);
            }
          }
          values = this.GetConstantValues(type);
          if (values.length > 0) {
            for (_l = 0, _len3 = values.length; _l < _len3; _l++) {
              value = values[_l];
              valueId = Guid.Create();
              valueNode = new Node(NodeType.Scalar, value.toString());
              this.provider.SetNode(valueId, valueNode);
              node.AddEdge(new Edge(valueId, new EdgeData(EdgeType.Contains, value.toString())));
            }
          }
          this.provider.SetNode(typeId, node);
        }
      }
      return typeId;
    };

    TypesService.prototype.GetConstantValues = function(type) {
      var item, list, _i, _len, _ref;
      list = [];
      if (type.isEnum && type.customAttributes.indexOf("FlagsAttribute") === -1) {
        _ref = type.enumValues;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          item = _ref[_i];
          list.push(item);
        }
      }
      if (type.name === "Boolean") {
        list.push(true);
        list.push(false);
      }
      return list;
    };

    TypesService.prototype.EnsureBasicScalarTypes = function() {
      var element, _i, _len, _ref, _results;
      _ref = this.supportedScalarTypes;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        element = _ref[_i];
        _results.push(this.AddType(element));
      }
      return _results;
    };

    TypesService.prototype.IsScalarType = function(typeId) {
      return this.scalarTypesTable.Contains(typeId);
    };

    TypesService.prototype.IsCollectionType = function(typeId) {
      return this.collectionTypesTable.Contains(typeId);
    };

    TypesService.prototype.IsDictionaryType = function(typeId) {
      return this.dictionaryTypesTable.Contains(typeId);
    };

    TypesService.prototype.GetTypeId = function(type) {
      var candidateNodeId, edge, name, node, _i, _len, _ref;
      name = this.GetTypeName(type);
      if (!(this.provider.GetNode(Constants.TypesNodeId, NodeAccess.Read) != null)) {
        return Guid.EMPTY;
      }
      _ref = this.provider.GetNode(Constants.TypesNodeId, NodeAccess.Read).edges.Array();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        edge = _ref[_i];
        if (edge.data.semantic === EdgeType.Contains) {
          candidateNodeId = edge.toNodeId;
          node = this.provider.GetNode(candidateNodeId, NodeAccess.Read);
          if (node.data.name.equals(name)) {
            return candidateNodeId;
          }
        }
      }
      return Guid.EMPTY;
    };

    TypesService.prototype.GetTypeIdCached = function(type) {
      var result;
      result = Guid.EMPTY;
      if (((result = this.typeToIdMapping.Get(type)) != null)) {
        return result;
      } else {
        return Guid.EMPTY;
      }
    };

    TypesService.prototype.GetTypeName = function(type) {
      if ((type != null) && (type.name != null)) {
        return type.name;
      } else {
        throw "Type is null";
      }
    };

    TypesService.prototype.AddTypeMember = function(name, type, isPrimaryKey) {
      var memberId, memberTypeId, node;
      memberId = Guid.Create();
      node = new Node(NodeType.TypeMember, name);
      if (isPrimaryKey) {
        node.values.Add(Constants.TypeMemberPrimaryKeyId, null);
      }
      memberTypeId = this.GetTypeId(type);
      if (memberTypeId.equals(Guid.EMPTY)) {
        memberTypeId = this.AddType(type);
      }
      node.AddEdge(new Edge(memberTypeId, new EdgeData(EdgeType.OfType, null)));
      this.provider.SetNode(memberId, node);
      return memberId;
    };

    TypesService.prototype.GetTypeMemberId = function(typeId, propertyName) {
      var candidateNode, edge, _i, _len, _ref;
      _ref = this.provider.GetNode(typeId, NodeAccess.Read).edges.Array();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        edge = _ref[_i];
        if (edge.data.semantic === EdgeType.Property) {
          candidateNode = this.provider.GetNode(edge.toNodeId, NodeAccess.Read);
          if (propertyName.equals(candidateNode.data)) {
            return edge.toNodeId;
          }
        }
      }
      return Guid.EMPTY;
    };

    TypesService.prototype.GetInstanceTypeId = function(instanceID) {
      return this.provider.GetNode(instanceId, NodeAccess.Read).FindEdge(new EdgeData(EdgeType.OfType, null)).toNodeId;
    };

    /*
         Returns type identifier for given member
    */


    TypesService.prototype.GetMemberTypeId = function(memberId) {
      return this.provider.GetNode(memberId, NodeAccess.Read).FindEdge(new EdgeData(EdgeType.OfType, null)).toNodeId;
    };

    TypesService.prototype.InitializeTypeSystem = function(types) {
      var collectionType, type, typeId, _i, _j, _len, _len1, _ref;
      this.typeToIdMapping = new Dictionary();
      this.typeIdToTypeMapping = new Dictionary();
      this.supportedScalarTypes = [BooleanType, StringType, Int32Type, Int64Type, DoubleType, DateTimeType, GuidType, TimeSpanType, ByteType, CharType];
      if (this.provider.Contains(Constants.TypesNodeId)) {

      } else {
        this.provider.SetNode(Constants.TypesNodeId, new Node(NodeType.TypesRoot, null));
        this.EnsureBasicScalarTypes();
        for (_i = 0, _len = types.length; _i < _len; _i++) {
          type = types[_i];
          this.AddType(type);
        }
      }
      _ref = this.GetTypes();
      for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
        typeId = _ref[_j];
        type = this.GetTypeFromId(typeId);
        this.typeToIdMapping.Add(type, typeId);
        this.typeIdToTypeMapping.Add(typeId, type);
        collectionType = null;
        if ((collectionType = UTILS.IsCollectionType(type)) != null) {
          this.collectionTypesTable.Add(typeId, type);
        }
        if ((collectionType = UTILS.IsDictionaryType(type)) != null) {
          this.dictionaryTypesTable.Add(typeId, type);
        }
      }
      this.CacheScalarTypes();
      return this.typeToIdMapping;
    };

    TypesService.prototype.GetTypes = function() {
      var edge, list, node, _i, _len, _ref;
      list = [];
      node = this.provider.GetNode(Constants.TypesNodeId, NodeAccess.Read);
      _ref = node.edges.Array();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        edge = _ref[_i];
        if (edge.data.semantic === EdgeType.Contains) {
          list.push(edge.toNodeId);
        }
      }
      return list;
    };

    TypesService.prototype.CacheScalarTypes = function() {
      var edge, type, typeId, _i, _len, _ref, _results;
      _ref = this.provider.GetNode(Constants.TypesNodeId, NodeAccess.Read).edges.Array();
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        edge = _ref[_i];
        if (edge.data.semantic === EdgeType.Contains) {
          typeId = edge.toNodeId;
          type = this.GetTypeFromId(typeId);
          if (this.IsSupportedScalarType(type)) {
            this.scalarTypesTable.Add(typeId, type);
          }
          if (type.isEnum) {
            _results.push(this.scalarTypesTable.Add(typeId, type));
          } else {
            _results.push(void 0);
          }
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    TypesService.prototype.IsSupportedScalarType = function(type) {
      var element, _i, _len, _ref;
      _ref = this.supportedScalarTypes;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        element = _ref[_i];
        if (element.equals(type)) {
          return true;
        }
      }
      return false;
    };

    TypesService.prototype.ValidateType = function(type) {};

    TypesService.prototype.CheckPrimaryKeyField = function(type) {
      var count, prop, properties, _i, _len;
      count = 0;
      properties = [];
      UTILS.ExtractProperties(type, properties);
      for (_i = 0, _len = properties.length; _i < _len; _i++) {
        prop = properties[_i];
        if (prop.GetCustomAttributes("PrimaryKeyAttribute")) {
          return true;
        }
      }
      return false;
    };

    TypesService.prototype.GetTypeEdges = function(typeId) {
      return this.provider.GetNode(typeId, NodeAccess.Read).edges.Array();
    };

    TypesService.prototype.GetDefaultPropertyValue = function(typeId) {
      var t, val;
      if (!this.IsScalarType(typeId)) {
        throw "Scalar type expected";
      }
      t = this.typeIdToTypeMapping.Get(typeId);
      val = null;
      if (t.equals(BooleanType)) {
        val = new IOGBoolean(false);
      } else {
        if (t.equals(DateTimeType)) {
          val = DateTime.MIN_DATE;
          val[TypesService.IOG_TYPE] = DateTimeType;
        } else {
          if (t.equals(TimeSpanType)) {
            val = TimeSpan.ZERO;
            val[TypesService.IOG_TYPE] = TimeSpanType;
          } else {
            if (t.equals(Int32Type)) {
              val = new Int32(0);
            } else {
              if (t.equals(Int64Type)) {
                val = new Int64(0);
              } else {
                if (t.equals(DoubleType)) {
                  val = new Double(0);
                } else {
                  if (t.equals(ByteType)) {
                    val = new Byte(0);
                  } else {
                    if (t.equals(StringType)) {
                      val = new IOGString("");
                    } else {
                      if (t.equals(GuidType)) {
                        val = Guid.EMPTY;
                      } else {
                        if (t.isEnum) {
                          val = t.enumValues[0];
                        } else {
                          throw "Default undefined for type " + t.name;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      return val;
    };

    TypesService.prototype.GetTypeFromId = function(typeId) {
      var node;
      node = this.provider.GetNode(typeId, NodeAccess.Read);
      return UTILS.GetType(node.data);
    };

    TypesService.prototype.GetTypeFromIdCached = function(typeId) {
      return this.typeIdToTypeMapping.Get(typeId);
    };

    TypesService.prototype.IsSealedType = function(typeId) {
      var candidate, edge, _i, _j, _len, _len1, _ref, _ref1;
      if (typeId.name === "Type") {
        typeId = this.GetTypeId(type);
      }
      if (this.IsScalarType(typeId)) {
        return true;
      }
      _ref = this.GetTypes();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        candidate = _ref[_i];
        if (candidate !== typeId) {
          _ref1 = this.GetTypeEdges(candidate);
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            edge = _ref1[_j];
            if (edge.data.semantic === EdgeType.OfType) {
              if (edge.toNodeId === typeId) {
                return false;
              }
            }
          }
        }
      }
      return true;
    };

    TypesService.prototype.GetTypePrimaryKeyMemberId = function(typeId) {
      var edge, memberNode, _i, _len, _ref;
      _ref = this.GetTypeEdges(typeId);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        edge = _ref[_i];
        if (edge.data.semantic === EdgeType.Property) {
          memberNode = this.provider.GetNode(edge.toNodeId, NodeAccess.Read);
          if (memberNode.values.Contains(Constants.TypeMemberPrimaryKeyId)) {
            return edge.toNodeId;
          }
        }
      }
      return Guid.EMPTY;
    };

    TypesService.prototype.GetMemberName = function(typeId, memberId) {
      return this.provider.GetNode(memberId, NodeAccess.Read).data;
    };

    TypesService.prototype.GetRegisteredTypes = function() {
      return typeIdToTypeMapping.keys;
    };

    return TypesService;

  })();

  window.ObjectInstancesService = (function() {

    function ObjectInstancesService(provider, typesService) {
      this.provider = provider;
      this.typesService = typesService;
    }

    ObjectInstancesService.prototype.NewInstance = function(typeId) {
      var id, node;
      id = Guid.Create();
      node = new Node(NodeType.Object, null);
      node.commited = false;
      node.AddEdge(new Edge(typeId, new EdgeData(EdgeType.OfType, null)));
      this.InitializeInstance(node, typeId);
      this.provider.SetNode(id, node);
      return id;
    };

    ObjectInstancesService.prototype.GetScalarInstanceMember = function(instanceId, memberId) {
      return this.provider.GetNode(instanceId, NodeAccess.Read).values.Get(memberId);
    };

    ObjectInstancesService.prototype.GetScalarInstanceValue = function(valueInstanceId) {
      return this.provider.GetNode(valueInstanceId, NodeAccess.Read).data;
    };

    ObjectInstancesService.prototype.GetReferenceInstanceMember = function(instanceId, memberId) {
      var edge, isPermanent, node, rezObject;
      node = this.provider.GetNode(instanceId, NodeAccess.Read);
      edge = node.FindEdge(new EdgeData(EdgeType.Property, memberId));
      isPermanent = (edge.data.Flags === EdgeFlags.Permanent) && node.commited;
      rezObject = {
        "guid": edge.toNodeId,
        "isPermanet": isPermanent
      };
      return rezObject;
    };

    ObjectInstancesService.prototype.SetScalarInstanceMember = function(instanceId, memberId, value) {
      var node;
      node = this.provider.GetNode(instanceId, NodeAccess.ReadWrite);
      if (node.values.Contains(memberId)) {
        node.values.Set(memberId, value);
      } else {
        node.values.Add(memberId, value);
      }
      this.provider.SetNode(instanceId, node);
    };

    ObjectInstancesService.prototype.SetReferenceInstanceMember = function(instanceId, memberId, referenceId) {
      var node;
      node = this.provider.GetNode(instanceId, NodeAccess.ReadWrite);
      node.SetEdgeToNode(new EdgeData(EdgeType.Property, memberId), referenceId);
      this.provider.SetNode(instanceId, node);
    };

    ObjectInstancesService.prototype.InitializeInstance = function(instance, typeId) {
      var edge, isPermanentEdge, memberId, memberTypeId, value, _i, _len, _ref;
      _ref = this.typesService.GetTypeEdges(typeId);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        edge = _ref[_i];
        if (edge.data.semantic === EdgeType.Property) {
          memberId = edge.toNodeId;
          memberTypeId = this.typesService.GetMemberTypeId(memberId);
          if (this.typesService.IsScalarType(memberTypeId)) {
            value = this.typesService.GetDefaultPropertyValue(memberTypeId);
            instance.values.Add(memberId, value);
          } else {
            isPermanentEdge = edge.data.flags === EdgeFlags.Permanent;
            instance.AddEdge(new Edge(Constants.NullReferenceNodeId, new EdgeData(EdgeType.Property, memberId, isPermanentEdge ? EdgeFlags.Permanent : EdgeFlags.None)));
          }
        }
      }
    };

    ObjectInstancesService.prototype.GetInstanceTypeId = function(instanceId) {
      return this.provider.GetNode(instanceId, NodeAccess.Read).FindEdge(new EdgeData(EdgeType.OfType, null)).toNodeId;
    };

    ObjectInstancesService.prototype.SetImmutable = function(instanceId, memberId) {
      var edge, newEdge, node;
      node = this.provider.GetNode(instanceId, NodeAccess.ReadWrite);
      edge = node.FindEdge(new EdgeData(EdgeType.Property, memberId));
      node.Edges.Remove(edge.data);
      newEdge = new Edge(edge.toNodeId, new EdgeData(edge.data.semantic, edge.Data.Data, EdgeFlags.Permanent));
      node.AddEdge(newEdge);
      this.provider.SetNode(instanceId, node);
    };

    return ObjectInstancesService;

  })();

  window.Enumerator = (function() {
    var array, currentNumber;

    array = [];

    currentNumber = -1;

    function Enumerator(array) {
      if (array == null) {
        array = [];
      }
      this.array = array;
      this.currentNumber = -1;
    }

    Enumerator.prototype.MoveNext = function() {
      if (this.array.length > this.currentNumber + 1) {
        this.currentNumber = this.currentNumber + 1;
        return true;
      }
      return false;
    };

    Enumerator.prototype.Reset = function() {
      this.currentNumber = -1;
    };

    Enumerator.prototype.Current = function() {
      if (this.currentNumber >= 0 && this.currentNumber < this.array.length) {
        return this.array[this.currentNumber];
      }
      return null;
    };

    return Enumerator;

  })();

  Array.prototype.GetEnumerator = function() {
    return new Enumerator(this);
  };

  window.BPlusTreeEnumerator = (function() {

    function BPlusTreeEnumerator(nodes, rootNodeId, edgeType, currentLeaf) {
      this.nodes = nodes;
      this.rootNodeId = rootNodeId;
      this.edgeType = edgeType;
      this.currentLeaf = currentLeaf;
      this.currentLeaf = BPlusTreeOperations.LeftLeaf(nodes, nodes.GetNode(rootNodeId, NodeAccess.Read));
      this.currentLeafEnumerator = this.currentLeaf.edges.Array().GetEnumerator();
    }

    BPlusTreeEnumerator.prototype.Current = function() {
      return this.currentLeafEnumerator.Current();
    };

    BPlusTreeEnumerator.prototype.CurrentItem = function() {
      return this.currentLeafEnumerator.Current();
    };

    BPlusTreeEnumerator.prototype.MoveNext = function() {
      var res;
      res = false;
      res = this.MoveNextInternal();
      while (res && this.Current().data.semantic !== this.edgeType) {
        res = this.MoveNextInternal();
      }
      return res;
    };

    BPlusTreeEnumerator.prototype.MoveNextInternal = function() {
      var current, currentLeaf, res, sampleData;
      if (!(this.currentLeafEnumerator != null)) {
        return false;
      }
      current = this.Current();
      sampleData = null;
      if (current != null) {
        sampleData = current.data;
      }
      res = this.currentLeafEnumerator.MoveNext();
      if (res) {
        return true;
      } else {
        this.currentLeafEnumerator = null;
        currentLeaf = BPlusTreeOperations.NextLeaf(this.nodes, this.rootNodeId, sampleData);
        if (currentLeaf === null) {
          return false;
        } else {
          this.currentLeafEnumerator = currentLeaf.edges.values.GetEnumerator();
          return this.currentLeafEnumerator.MoveNext();
        }
      }
    };

    BPlusTreeEnumerator.prototype.Reset = function() {
      var currentLeaf;
      if (this.currentLeafEnumerator != null) {
        this.currentLeafEnumerator.Reset();
      }
      currentLeaf = BPlusTreeOperations.LeftLeaf(this.nodes, this.nodes.GetNode(this.rootNodeId, NodeAccess.Read));
      this.currentLeafEnumerator = currentLeaf.edges.Array().GetEnumerator();
    };

    return BPlusTreeEnumerator;

  })();

  window.SplitResult = (function() {

    function SplitResult(createdNodeId, createdNode, rightKey) {
      this.createdNodeId = createdNodeId;
      this.createdNode = createdNode;
      this.rightKey = rightKey;
    }

    return SplitResult;

  })();

  window.FindResult = (function() {

    function FindResult(nodeId, node) {
      this.nodeId = nodeId;
      this.node = node;
    }

    return FindResult;

  })();

  window.RemovalResult = (function() {

    function RemovalResult(remainingCount, wasRemoved, wasMerged) {
      this.remainingCount = remainingCount;
      this.wasRemoved = wasRemoved;
      this.wasMerged = wasMerged;
    }

    return RemovalResult;

  })();

  BPlusTreeOperationsClass = (function() {

    function BPlusTreeOperationsClass() {
      this.InitFields();
    }

    BPlusTreeOperationsClass.prototype.InitFields = function() {
      this.InternalNodeData = new Guid("46F41F60-F781-445A-A416-B35E0CA940B4");
      return this.LeafNodeData = new Guid("6DEFCDC7-4C59-4120-87C6-C72363751BE7");
    };

    BPlusTreeOperationsClass.prototype.CreateRootNode = function(nodeType, rootNodeId) {
      var node;
      node = new Node(nodeType, this.LeafNodeData);
      return node;
    };

    BPlusTreeOperationsClass.prototype.InsertEdge = function(nodes, rootNodeId, edge, treeOrder) {
      var node, result;
      if (treeOrder < 6) {
        throw "treeOrder is smaller then 6";
      }
      result = this.FindLeafNode(nodes, rootNodeId, edge.data);
      if (result.node.edges.Length() === treeOrder) {
        this.SplitTree(nodes, rootNodeId, true, edge.data, treeOrder);
        result = this.FindLeafNode(nodes, rootNodeId, edge.data);
      }
      if (!result.node.data.equals(this.LeafNodeData)) {
        throw "Leaf node expected";
      }
      node = nodes.GetNode(result.nodeId, NodeAccess.ReadWrite);
      node.AddEdge(edge);
      return nodes.SetNode(result.nodeId, node);
    };

    BPlusTreeOperationsClass.prototype.TryFindEdge = function(nodes, rootNodeId, data) {
      var result, value;
      result = this.FindLeafNode(nodes, rootNodeId, data);
      if (result === null || result.node === null) {
        return {
          "result": false,
          "value": null
        };
      } else {
        if (!result.node.data.equals(this.LeafNodeData)) {
          return {
            "result": false,
            "value": null
          };
        }
        value = result.node.edges.Get(data);
        return {
          "result": value != null,
          "value": value
        };
      }
    };

    BPlusTreeOperationsClass.prototype.TrySetEdgeToNode = function(nodes, rootNodeId, data, toNodeId) {
      var result;
      result = this.FindLeafNode(nodes, rootNodeId, data);
      if (result === null) {
        throw "Key not found";
      } else {
        if (result.node.data !== this.LeafNodeData) {
          throw "Leaf node expected";
        }
        result.node.SetEdgeToNode(data, toNodeId);
        nodes.SetNode(result.nodeId, result.node);
        return true;
      }
    };

    BPlusTreeOperationsClass.prototype.RemoveEdge = function(nodes, rootNodeId, data, treeOrder) {
      var result;
      result = this.RemoveEdgeRecursive(nodes, rootNodeId, data, treeOrder);
      return result.wasRemoved;
    };

    BPlusTreeOperationsClass.prototype.Count = function(nodes, rootNodeId, data) {
      var edge, node, sum, _i, _j, _len, _len1, _ref, _ref1;
      node = nodes.GetNode(rootNodeId, NodeAccess.Read);
      if (node.data.equals(this.LeafNodeData)) {
        sum = 0;
        _ref = node.edges.Array();
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          edge = _ref[_i];
          if (edge.data.semantic === data) {
            sum = sum + 1;
          }
        }
        return sum;
      } else {
        sum = 0;
        _ref1 = node.edges.Array();
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          edge = _ref1[_j];
          sum = sum + this.Count(nodes, edge.toNodeId, data);
        }
        return sum;
      }
    };

    BPlusTreeOperationsClass.prototype.GetEnumerator = function(nodes, rootNodeId, edgeType) {
      return new BPlusTreeEnumerator(nodes, rootNodeId, edgeType);
    };

    BPlusTreeOperationsClass.prototype.Clone = function(nodes, sourceId, destinationId) {
      var edge, newNode, node, subId, _i, _len, _ref;
      node = nodes.GetNode(sourceId, NodeAccess.Read);
      if (node.data === this.InternalNodeData) {
        newNode = new Node(node.nodeType, node.data);
        _ref = node.edges.values;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          edge = _ref[_i];
          subId = Guid.Create();
          this.Clone(nodes, edge.toNodeId, subId);
          newNode.AddEdge(new Edge(subId, edge.data));
        }
        return nodes.SetNode(destinationId, newNode);
      } else {
        if (node.data === this.LeafNodeData) {
          newNode = new Node(node.nodeType, node.data, node.edges);
          return nodes.SetNode(destinationId, newNode);
        } else {
          throw "Invalid operation";
        }
      }
    };

    BPlusTreeOperationsClass.prototype.FindLeafNode = function(nodes, rootNodeId, data) {
      var id, leadingEdge, node;
      node = nodes.GetNode(rootNodeId, NodeAccess.Read);
      id = rootNodeId;
      if (!(node != null)) {
        return new FindResult(null, null);
      }
      while (node.data === this.InternalNodeData) {
        leadingEdge = this.FindLeadingEdge(data, node);
        node = nodes.GetNode(leadingEdge.toNodeId, NodeAccess.Read);
        id = leadingEdge.toNodeId;
      }
      return new FindResult(id, node);
    };

    BPlusTreeOperationsClass.prototype.FindLeadingEdge = function(data, node) {
      return node.edges.Get(node.edges.keys[this.FindLeadingEdgeIndex(data, node)]);
    };

    BPlusTreeOperationsClass.prototype.FindLeadingEdgeIndex = function(data, node) {
      var i, keys, step;
      if (node.data === this.InternalNodeData) {
        keys = node.edges.keys;
        i = 0;
        step = keys.length;
        while (true) {
          if (step > 1) {
            step = Math.floor(step / 2);
          }
          if (data.compareTo(keys[i]) < 0) {
            if (i === 0) {
              return i;
            }
            if (data.compareTo(keys[i - 1]) >= 0) {
              return i;
            } else {
              i = i - step;
            }
          } else {
            if (i === keys.length - 1) {
              return i;
            } else {
              i = i + step;
            }
          }
        }
      } else {
        throw "Internal node expected";
      }
    };

    BPlusTreeOperationsClass.prototype.SplitTree = function(nodes, nodeId, isRoot, data, treeOrder) {
      var currentNode, eleme, i, j, key, keys, leadingEdge, leftNode, leftNodeId, newInternal, newInternalId, newLeaf, newLeafId, nrToRemove, result, rightNode, rightNodeId, _i, _j, _k, _l, _len, _len1, _m, _ref;
      currentNode = nodes.GetNode(nodeId, NodeAccess.ReadWrite);
      if (isRoot) {
        if (currentNode.data.equals(this.InternalNodeData)) {
          leadingEdge = this.FindLeadingEdge(data, currentNode);
          result = this.SplitTree(nodes, leadingEdge.toNodeId, false, data, treeOrder);
          if (result !== null) {
            currentNode.AddEdge(new Edge(result.createdNodeId, result.rightKey));
            if (currentNode.edges.Length() === (treeOrder + 1)) {
              leftNodeId = Guid.Create();
              rightNodeId = Guid.Create();
              leftNode = new Node(NodeType.TreeInternal, this.InternalNodeData);
              rightNode = new Node(NodeType.TreeInternal, this.InternalNodeData);
              keys = currentNode.edges.keys;
              for (i = _i = 0, _len = keys.length; _i < _len; i = ++_i) {
                eleme = keys[i];
                if (i < Math.floor(keys.length / 2)) {
                  leftNode.AddEdge(currentNode.edges.Get(keys[i]));
                } else {
                  rightNode.AddEdge(currentNode.edges.Get(keys[i]));
                }
              }
              this.SetLastInternalKey(leftNode);
              this.SetLastInternalKey(rightNode);
              currentNode.edges.Clear();
              currentNode.AddEdge(new Edge(leftNodeId, this.LeftEdge(nodes, rightNode).data));
              currentNode.AddEdge(new Edge(rightNodeId, EdgeDataSingleton.MAX_VALUE));
              nodes.SetNode(leftNodeId, leftNode);
              nodes.SetNode(rightNodeId, rightNode);
            }
            nodes.SetNode(nodeId, currentNode);
          } else {
            return null;
          }
        } else {
          if (currentNode.edges.Length() === treeOrder) {
            leftNodeId = Guid.Create();
            rightNodeId = Guid.Create();
            leftNode = new Node(NodeType.TreeLeaf, this.LeafNodeData);
            rightNode = new Node(NodeType.TreeLeaf, this.LeafNodeData);
            keys = currentNode.edges.keys;
            for (i = _j = 0, _len1 = keys.length; _j < _len1; i = ++_j) {
              key = keys[i];
              if (i < Math.floor(keys.length / 2)) {
                leftNode.AddEdge(currentNode.edges.Get(keys[i]));
              } else {
                rightNode.AddEdge(currentNode.edges.Get(keys[i]));
              }
            }
            currentNode.edges.Clear();
            currentNode.AddEdge(new Edge(leftNodeId, this.LeftEdge(nodes, rightNode).data));
            currentNode.AddEdge(new Edge(rightNodeId, EdgeDataSingleton.MAX_VALUE));
            currentNode.SetData(this.InternalNodeData);
            nodes.SetNode(leftNodeId, leftNode);
            nodes.SetNode(rightNodeId, rightNode);
            nodes.SetNode(nodeId, currentNode);
          }
        }
        return null;
      } else {
        if (currentNode.data.equals(this.InternalNodeData)) {
          leadingEdge = this.FindLeadingEdge(data, currentNode);
          result = this.SplitTree(nodes, leadingEdge.toNodeId, false, data, treeOrder);
          if (result !== null) {
            currentNode.AddEdge(new Edge(result.createdNodeId, result.rightKey));
            if (currentNode.edges.Length() === treeOrder) {
              newInternalId = Guid.Create();
              newInternal = new Node(NodeType.TreeInternal, this.InternalNodeData);
              keys = currentNode.edges.keys;
              for (i in keys) {
                key = keys[i];
                if (i >= Math.floor(keys.length / 2)) {
                  break;
                }
                newInternal.AddEdge(currentNode.edges.Get(key));
              }
              nrToRemove = Math.floor(keys.length / 2);
              for (j = _k = 0; 0 <= nrToRemove ? _k <= nrToRemove : _k >= nrToRemove; j = 0 <= nrToRemove ? ++_k : --_k) {
                currentNode.edges.Remove(keys[j]);
              }
              this.SetLastInternalKey(newInternal);
              nodes.SetNode(newInternalId, newInternal);
              nodes.SetNode(nodeId, currentNode);
              return new SplitResult(newInternalId, newInternal, this.LeftEdge(nodes, currentNode).data);
            } else {
              nodes.SetNode(nodeId, currentNode);
              return null;
            }
          } else {
            return null;
          }
        } else {
          if (currentNode.data.equals(this.LeafNodeData)) {
            newLeafId = Guid.Create();
            newLeaf = new Node(NodeType.TreeLeaf, this.LeafNodeData);
            keys = currentNode.edges.keys;
            for (i = _l = 0, _ref = Math.floor(keys.length / 2); 0 <= _ref ? _l <= _ref : _l >= _ref; i = 0 <= _ref ? ++_l : --_l) {
              newLeaf.AddEdge(currentNode.edges.Get(keys[i]));
            }
            nrToRemove = keys.length / 2;
            for (i = _m = 0; 0 <= nrToRemove ? _m <= nrToRemove : _m >= nrToRemove; i = 0 <= nrToRemove ? ++_m : --_m) {
              currentNode.edges.Remove(keys[i]);
            }
            nodes.SetNode(newLeafId, newLeaf);
            nodes.SetNode(nodeId, currentNode);
            return new SplitResult(newLeafId, newLeaf, this.LeftEdge(nodes, currentNode).data);
          } else {
            throw "Unexpected node data";
          }
        }
      }
    };

    BPlusTreeOperationsClass.prototype.LeftLeaf = function(nodes, node) {
      if (node.data.equals(this.LeafNodeData)) {
        return node;
      } else {
        return this.LeftLeaf(nodes, nodes.GetNode(node.edges.Get(node.edges.keys[0]).toNodeId, NodeAccess.Read));
      }
    };

    BPlusTreeOperationsClass.prototype.NextLeaf = function(nodes, rootNodeId, sampleData) {
      var id, leadingEdgeIndex, nextInternalParentId, node;
      node = nodes.GetNode(rootNodeId, NodeAccess.Read);
      id = rootNodeId;
      nextInternalParentId = Guid.EMPTY;
      while (node.data.equals(this.InternalNodeData)) {
        leadingEdgeIndex = this.FindLeadingEdgeIndex(sampleData, node);
        if (leadingEdgeIndex < node.edges.Length() - 1) {
          nextInternalParentId = node.edges[node.edges.keys[leadingEdgeIndex + 1]].toNodeId;
        }
        node = nodes.GetNode(node.edges.Get(node.edges.keys[leadingEdgeIndex]).toNodeId, NodeAccess.Read);
      }
      if (nextInternalParentId === Guid.EMPTY) {
        return null;
      } else {
        return this.LeftLeaf(nodes, nodes.GetNode(nextInternalParentId, NodeAccess.Read));
      }
    };

    BPlusTreeOperationsClass.prototype.LeftEdge = function(nodes, node) {
      if (node.data.equals(this.LeafNodeData)) {
        return node.edges.Get(node.edges.keys[0]);
      } else {
        return this.LeftEdge(nodes, nodes.GetNode(node.edges.Get(node.edges.keys[0]).toNodeId, NodeAccess.Read));
      }
    };

    BPlusTreeOperationsClass.prototype.RightEdge = function(nodes, node) {
      if (node.data.equals(this.LeafNodeData)) {
        if (node.edges.Length() > 0) {
          return node.edges.Get(node.edges.keys[node.edges.Length() - 1]);
        } else {
          return null;
        }
      }
    };

    BPlusTreeOperationsClass.prototype.SetLastInternalKey = function(node) {
      var edge, lastKey;
      lastKey = node.edges.keys[node.edges.Length() - 1];
      edge = node.edges.Get(lastKey);
      if (!edge.data.equals(EdgeDataSingleton.MAX_VALUE)) {
        node.edges.Remove(lastKey);
        return node.AddEdge(new Edge(edge.toNodeId, EdgeDataSingleton.MAX_VALUE));
      }
    };

    BPlusTreeOperationsClass.prototype.RemoveEdgeRecursive = function(nodes, nodeId, data, treeOrder) {
      var edge, edgeIndex, node, removeResult, res;
      node = nodes.GetNode(nodeId, NodeAccess.ReadWrite);
      if (node.data.equals(this.LeafNodeData)) {
        removeResult = node.edges.Remove(data);
        res = new RemovalResult(node.edges.Length(), removeResult, false);
        return res;
      } else {
        edgeIndex = this.FindLeadingEdgeIndex(data, node);
        edge = node.edges.Get(node.edges.keys[edgeIndex]);
        res = this.RemoveEdgeRecursive(nodes, edge.toNodeId, data, treeOrder);
        if (!res.wasRemoved) {
          return res;
        }
        if (res.remainingCount < Math.floor(treeOrder / 2)) {
          if (edgeIndex < node.edges.Length() - 1) {
            res = this.MergeNodes(nodes, node, edgeIndex, edgeIndex + 1, treeOrder);
            return res;
          } else {
            res = this.MergeNodes(nodes, node, edgeIndex - 1, edgeIndex, treeOrder);
            return res;
          }
        } else {
          return res;
        }
      }
    };

    BPlusTreeOperationsClass.prototype.MergeNodes = function(nodes, node, leftIndex, rightIndex, treeOrder) {
      var childEdge, i, leftKey, leftNode, leftNodeId, maxEdge, maxEdgeKey, numberToTake, removalKey, rightKey, rightNode, rightNodeId, _i, _j, _k, _l, _len, _ref, _ref1, _ref2;
      leftKey = node.edges.keys[leftIndex];
      leftNodeId = node.edges.Get(leftKey).toNodeId;
      leftNode = nodes.GetNode(leftNodeId, NodeAccess.ReadWrite);
      rightKey = node.edges.keys[rightIndex];
      rightNodeId = node.edges.Get(rightKey).toNodeId;
      rightNode = nodes.GetNode(rightNodeId, NodeAccess.ReadWrite);
      if (!leftNode.data.equals(rightNode.data)) {
        throw "Both nodes must be of same type";
      }
      if (leftNode.data.equals(this.InternalNodeData)) {
        maxEdgeKey = leftNode.edges.keys[leftNode.edges.Length() - 1];
        maxEdge = leftNode.edges.Get(maxEdgeKey);
        leftNode.edges.Remove(maxEdgeKey);
        leftNode.AddEdge(new Edge(maxEdge.toNodeId, this.LeftEdge(nodes, rightNode).data));
      }
      if ((leftNode.edges.Length() + rightNode.edges.Length()) <= treeOrder) {
        for (i = _i = 0, _ref = leftNode.edges.Length() - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
          removalKey = leftNode.edges.keys[i];
          rightNode.AddEdge(leftNode.edges.Get(removalKey));
        }
        nodes.SetNode(rightNodeId, rightNode);
        nodes.Remove(leftNodeId);
        node.edges.Remove(leftKey);
        if (node.edges.Length() === 1) {
          node.SetData(rightNode.data);
          node.edges.Clear();
          _ref1 = rightNode.edges.Array();
          for (_j = 0, _len = _ref1.length; _j < _len; _j++) {
            childEdge = _ref1[_j];
            node.AddEdge(childEdge);
          }
          nodes.Remove(rightNodeId);
        }
        return new RemovalResult(node.edges.Length(), true, true);
      } else {
        numberToTake = Math.floor((leftNode.edges.Length() + rightNode.edges.Length()) / 2) - leftNode.edges.Length();
        if (numberToTake > 0) {
          for (i = _k = 0; 0 <= numberToTake ? _k <= numberToTake : _k >= numberToTake; i = 0 <= numberToTake ? ++_k : --_k) {
            removalKey = rightNode.edges.keys[0];
            leftNode.AddEdge(rightNode.edges.Get(removalKey));
            rightNode.edges.Remove(removalKey);
          }
          node.edges.Remove(leftKey);
          node.AddEdge(new Edge(leftNodeId, this.LeftEdge(nodes, rightNode).data));
          nodes.SetNode(leftNodeId, leftNode);
          nodes.SetNode(rightNodeId, rightNode);
          return new RemovalResult(node.edges.Length(), true, true);
        } else {
          if (numberToTake < 0) {
            for (i = _l = 0, _ref2 = Math.abs(numberToTake); 0 <= _ref2 ? _l <= _ref2 : _l >= _ref2; i = 0 <= _ref2 ? ++_l : --_l) {
              removalKey = leftNode.edges.keys[leftNode.edges.Length() - 1];
              rightNode.AddEdge(leftNode.edges.Get(removalKey));
              leftNode.edges.Remove(removalKey);
            }
            node.edges.Remove(leftKey);
            node.AddEdge(new Edge(leftNodeId, this.LeftEdge(nodes, rightNode).data));
            nodes.SetNode(leftNodeId, leftNode);
            nodes.SetNode(rightNodeId, rightNode);
            return new RemovalResult(node.edges.Length(), true, true);
          }
          throw "Nothing to copy";
        }
      }
    };

    return BPlusTreeOperationsClass;

  })();

  window.BPlusTreeOperations = new BPlusTreeOperationsClass();

  window.CollectionInstancesService = (function() {

    function CollectionInstancesService(provider, typesService) {
      this.provider = provider;
      this.typesService = typesService;
      this.bplusTreeOrder = 100;
    }

    CollectionInstancesService.prototype.NewInstance = function(typeId) {
      var id, node;
      id = Guid.Create();
      node = BPlusTreeOperations.CreateRootNode(NodeType.Collection, id);
      this.provider.SetNode(id, node);
      BPlusTreeOperations.InsertEdge(this.provider, id, new Edge(typeId, new EdgeData(EdgeType.OfType, null)), this.bplusTreeOrder);
      this.provider.SetNode(id, node);
      return id;
    };

    CollectionInstancesService.prototype.AddScalar = function(instanceId, itemTypeId, value, key) {
      var data, id, node;
      if (key == null) {
        key = "";
      }
      id = Guid.Create();
      node = new Node(NodeType.Scalar, value);
      this.provider.SetNode(id, node);
      if (key === "") {
        data = Guid.Create();
      } else {
        data = key;
      }
      return BPlusTreeOperations.InsertEdge(this.provider, instanceId, new Edge(id, new EdgeData(EdgeType.ListItem, data)), this.bplusTreeOrder);
    };

    CollectionInstancesService.prototype.AddReference = function(instanceId, referenceId, key) {
      var data;
      if (key == null) {
        key = "";
      }
      if (key === "") {
        data = Guid.Create();
      } else {
        data = key;
      }
      return BPlusTreeOperations.InsertEdge(this.provider, instanceId, new Edge(referenceId, new EdgeData(EdgeType.ListItem, data)), this.bPlusTreeOrder);
    };

    CollectionInstancesService.prototype.Clear = function(instanceId) {
      var enumerator, key, removalKeys, _i, _len, _results;
      removalKeys = [];
      enumerator = this.GetEnumerator(instanceId);
      while (enumerator.MoveNext()) {
        removalKeys.push(enumerator.Current().data);
      }
      _results = [];
      for (_i = 0, _len = removalKeys.length; _i < _len; _i++) {
        key = removalKeys[_i];
        _results.push(BPlusTreeOperations.RemoveEdge(this.provider, instanceId, key, this.bPlusTreeOrder));
      }
      return _results;
    };

    CollectionInstancesService.prototype.ContainsScalar = function(instanceId, value, key) {
      var enumerator, node;
      if (key == null) {
        key = "";
      }
      if (key === "") {
        enumerator = this.GetEnumerator(instanceId);
        while (enumerator.MoveNext()) {
          node = this.provider.GetNode(enumerator.Current().toNodeId, NodeAccess.Read);
          if (node.data.equlas(value)) {
            return true;
          }
        }
        return false;
      } else {
        return BPlusTreeOperations.TryFindEdge(this.provider, instanceId, new EdgeData(EdgeType.ListItem, key)).result;
      }
    };

    CollectionInstancesService.prototype.ContainsReference = function(instanceId, referenceId, key) {
      var enumerator;
      if (key == null) {
        key = "";
      }
      if (key === "") {
        enumerator = this.GetEnumerator(instanceId);
        while (enumerator.MoveNext()) {
          if (enumerator.Current().toNodeId.equals(referenceId)) {
            return true;
          }
        }
        return false;
      } else {
        return BPlusTreeOperations.TryFindEdge(this.provider, instanceId, new EdgeData(EdgeType.ListItem, key)).result;
      }
    };

    CollectionInstancesService.prototype.Count = function(instanceId) {
      return BPlusTreeOperations.Count(this.provider, instanceId, EdgeType.ListItem);
    };

    CollectionInstancesService.prototype.MaxOrderedIdentifier = function(instanceId) {
      if (this.Count(instanceId) === 0) {
        return 0;
      } else {
        return BPlusTreeOperations.RightEdge(this.provider, this.provider.GetNode(instanceId, NodeAccess.Read)).data.data;
      }
    };

    CollectionInstancesService.prototype.RemoveScalar = function(instanceId, value, key) {
      var enumerator, node;
      if (key == null) {
        key = "";
      }
      if (key === "") {
        enumerator = this.GetEnumerator(instanceId);
        while (enumerator.MoveNext()) {
          node = this.provider.GetNode(enumerator.Current().toNodeId, NodeAccess.Read);
          if (node.data.equals(value)) {
            return BPlusTreeOperations.RemoveEdge(this.provider, instanceId, enumerator.Current().data, this.bplusTreeOrder);
          }
        }
        return false;
      } else {
        return BPlusTreeOperations.RemoveEdge(this.provider, instanceId, new EdgeData(EdgeType.ListItem, key), this.bplusTreeOrder);
      }
    };

    CollectionInstancesService.prototype.RemoveReference = function(instanceId, referenceId, key) {
      var enumerator;
      if (key == null) {
        key = "";
      }
      if (key === "") {
        enumerator = this.GetEnumerator(instanceId);
        while (enumerator.MoveNext()) {
          if (numerator.Current().toNodeId.equals(referenceId)) {
            return BPlusTreeOperations.RemoveEdge(this.provider, instanceId, enumerator.Current().data, this.bplusTreeOrder);
          }
        }
        return false;
      } else {
        return BPlusTreeOperations.RemoveEdge(this.provider, instanceId, new EdgeData(EdgeType.ListItem, key), this.bplusTreeOrder);
      }
    };

    CollectionInstancesService.prototype.IsCollectionInstance = function(referenceId) {
      var data, isEmptyGuid, isInternalNode, isLeafNode;
      data = this.provider.GetNode(referenceId, NodeAccess.Read).data;
      if (data === null) {
        data = Guid.EMPTY;
      }
      isEmptyGuid = data.equals(Guid.EMPTY);
      isInternalNode = (data.equals(BPlusTreeOperations.InternalNodeData), isLeafNode = data.equals(BPlusTreeOperations.LeafNodeData));
      return !isEmptyGuid && isInternalNode || isLeafNode;
    };

    CollectionInstancesService.prototype.GetInstanceTypeId = function(referenceId) {
      var rez;
      rez = BPlusTreeOperations.TryFindEdge(this.provider, referenceId, new EdgeData(EdgeType.OfType, null));
      if (rez.result) {
        return rez.value.toNodeId;
      } else {
        return Guid.EMPTY;
      }
    };

    CollectionInstancesService.prototype.GetEnumerator = function(instanceId) {
      return BPlusTreeOperations.GetEnumerator(this.provider, instanceId, EdgeType.ListItem);
    };

    CollectionInstancesService.prototype.TryFindReferenceByKey = function(instanceId, key) {
      var rez;
      rez = BPlusTreeOperations.TryFindEdge(this.provider, instanceId, new EdgeData(EdgeType.ListItem, key));
      if (rez.result) {
        return {
          "result": true,
          "value": rez.value
        };
      } else {
        return {
          "result": false,
          "value": Guid.EMPTY
        };
      }
    };

    return CollectionInstancesService;

  })();

  window.DictionaryInstancesService = (function() {

    function DictionaryInstancesService(provider, typesService) {
      this.provider = provider;
      this.typesService = typesService;
      this.bplusTreeOrder = 100;
    }

    DictionaryInstancesService.prototype.NewInstance = function(typeId) {
      var id, node;
      id = Guid.Create();
      node = BPlusTreeOperations.CreateRootNode(NodeType.Dictionary, id);
      this.provider.SetNode(id, node);
      BPlusTreeOperations.InsertEdge(this.provider, id, new Edge(typeId, new EdgeData(EdgeType.OfType, null)), this.bplusTreeOrder);
      this.provider.SetNode(id, node);
      return id;
    };

    DictionaryInstancesService.prototype.AddScalar = function(instanceId, itemTypeId, key, value) {
      var id, node;
      id = Guid.Create();
      node = new Node(NodeType.Scalar, value);
      this.provider.SetNode(id, node);
      return BPlusTreeOperations.InsertEdge(this.provider, instanceId, new Edge(id, new EdgeData(EdgeType.ListItem, key)), this.bplusTreeOrder);
    };

    DictionaryInstancesService.prototype.AddReference = function(instanceId, key, referenceId) {
      return BPlusTreeOperations.InsertEdge(this.provider, instanceId, new Edge(referenceId, new EdgeData(EdgeType.ListItem, key)), this.bplusTreeOrder);
    };

    DictionaryInstancesService.prototype.ContainsKey = function(instanceId, key) {
      return BPlusTreeOperations.TryFindEdge(this.provider, instanceId, new EdgeData(EdgeType.ListItem, key)).result;
    };

    DictionaryInstancesService.prototype.GetEnumerator = function(instanceId) {
      return BPlusTreeOperations.GetEnumerator(this.provider, instanceId, EdgeType.ListItem);
    };

    DictionaryInstancesService.prototype.Remove = function(instanceId, key) {
      return BPlusTreeOperations.RemoveEdge(this.provider, instanceId, new EdgeData(EdgeType.ListItem, key), this.bplusTreeOrder);
    };

    DictionaryInstancesService.prototype.TryGetScalar = function(instanceId, key, value) {
      var rez;
      rez = BPlusTreeOperations.TryFindEdge(provider, instanceId, new EdgeData(EdgeType.ListItem, key));
      if (rez.result) {
        value = this.provider.GetNode(rez.value.toNodeId, NodeAccess.Read).data;
        return {
          "result": true,
          "value": value
        };
      } else {
        return {
          "result": false,
          "value": null
        };
      }
    };

    DictionaryInstancesService.prototype.TryGetReference = function(instanceId, key) {
      var rez;
      rez = BPlusTreeOperations.TryFindEdge(provider, instanceId, new EdgeData(EdgeType.ListItem, key));
      if (rez.result) {
        return {
          "result": rez.result,
          "value": rez.value.toNodeId
        };
      } else {
        return {
          "result": false,
          "value": Guid.EMPTY
        };
      }
    };

    DictionaryInstancesService.prototype.SetScalar = function(instanceId, itemTypeId, key, value) {
      var id, node;
      id = Guid.Create();
      node = new Node(NodeType.Scalar, value);
      this.provider.SetNode(id, node);
      if (!BPlusTreeOperations.TrySetEdgeToNode(this.provider, instanceId, new EdgeData(EdgeType.ListItem, key), id)) {
        throw "Item not found with the specified key";
      }
    };

    DictionaryInstancesService.prototype.SetReference = function(instanceId, key, referenceId) {
      if (!BPlusTreeOperations.TrySetEdgeToNode(this.provider, instanceId, new EdgeData(EdgeType.ListItem, key), referenceId)) {
        throw "Item not found with the specified key";
      }
    };

    DictionaryInstancesService.prototype.Clear = function(instanceId) {
      var enumerator, key, removalKeys, _i, _len, _results;
      removalKeys = [];
      enumerator = this.GetEnumerator(instanceId);
      while (enumerator.MoveNext()) {
        removalKeys.Add(enumerator.Current().data);
      }
      _results = [];
      for (_i = 0, _len = removalKeys.length; _i < _len; _i++) {
        key = removalKeys[_i];
        _results.push(BPlusTreeOperations.RemoveEdge(this.provider, instanceId, key, this.bplusTreeOrder));
      }
      return _results;
    };

    DictionaryInstancesService.prototype.Count = function(instanceId) {
      return BPlusTreeOperations.Count(this.provider, instanceId, EdgeType.ListItem);
    };

    return DictionaryInstancesService;

  })();

  window.TableElement = (function() {

    function TableElement(target, lastAccess) {
      this.target = target;
      this.accessCount = lastAccess;
    }

    TableElement.prototype.compareTo = function(other) {
      if (hasOwnProperty(other, "accessCount")) {
        throw "Other object has not field accessCount!";
      }
      if (this.accessCount < other.accessCount) {
        return -1;
      } else {
        if (this.accessCount > other.accessCount) {
          return 1;
        } else {
          return 0;
        }
      }
    };

    return TableElement;

  })();

  window.LimitedProxyMap = (function() {

    function LimitedProxyMap(minElements, maxElements) {
      this.minElements = minElements != null ? minElements : 50000;
      this.maxElements = maxElements != null ? maxElements : 100000;
      this.table = new SortedList();
    }

    LimitedProxyMap.prototype.AddProxy = function(instanceId, proxy) {
      if (proxy === null) {
        throw "proxy object is null";
      }
      if (this.table.Length() > this.maxElements) {
        this.Cleanup();
      }
      if (!this.table.Contains(instanceId)) {
        return this.table.Add(instanceId, new TableElement(proxy, 0));
      } else {
        return this.table[instanceId].accessCount++;
      }
    };

    LimitedProxyMap.prototype.TryGetProxy = function(instanceId) {
      var element, proxy;
      if (this.table.Contains(instanceId)) {
        element = this.table.Get(instanceId);
        proxy = element.target;
        element.accessCount++;
        return {
          "result": proxy !== null,
          "value": proxy
        };
      } else {
        return {
          "result": false,
          "value": null
        };
      }
    };

    LimitedProxyMap.prototype.Cleanup = function() {
      var item, key, nrToRemove, _i, _j, _len, _len1, _ref, _ref1, _results;
      if (this.table.Length() > this.minElements) {
        int(nrToRemove = table.Length() - this.minElements);
        _ref = this.table.keys;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          key = _ref[_i];
          this.table.Remove(key);
          nrToRemove--;
          if (nrToRemove === 0) {
            break;
          }
        }
        _ref1 = this.table.values;
        _results = [];
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          item = _ref1[_j];
          _results.push(item.accessCount = 0);
        }
        return _results;
      }
    };

    LimitedProxyMap.prototype.UpgradeProxies = function(mapping) {
      var element, key, keys, newKey, reference, _i, _j, _len, _len1, _ref;
      keys = [];
      _ref = this.table.keys;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        key = _ref[_i];
        keys.push(key);
      }
      for (_j = 0, _len1 = keys.length; _j < _len1; _j++) {
        key = keys[_j];
        if (mapping.Contains(key)) {
          element = this.table.Get(key);
          reference = element.target;
          newKey = mapping.Get(key);
          UTILS.SetItemId(reference, newKey);
          this.table.Add(newKey, element);
          this.table.Remove(key);
        }
      }
      return this.Cleanup();
    };

    LimitedProxyMap.prototype.InvalidateProxies = function(instances) {
      var key, target, _i, _j, _len, _len1, _ref, _ref1, _results, _results1;
      if ((instances != null)) {
        _ref = this.table.keys;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          key = _ref[_i];
          if (instances.Contains(key)) {
            target = (table.Get(key)).target;
            if (target != null) {
              _results.push(UTILS.SetItemId(target, Guid.EMPTY));
            } else {
              _results.push(void 0);
            }
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      } else {
        _ref1 = this.table.keys;
        _results1 = [];
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          key = _ref1[_j];
          target = this.table.Get(key).taget;
          if (target != null) {
            _results1.push(UTILS.SetItemId(target, Guid.Empty));
          } else {
            _results1.push(void 0);
          }
        }
        return _results1;
      }
    };

    return LimitedProxyMap;

  })();

  window.ActivatorClass = (function() {

    function ActivatorClass() {}

    ActivatorClass.prototype.CreateInstance = function(type, facade, instanceId, readOnly) {};

    return ActivatorClass;

  })();

  Activator = new ActivatorClass();

  window.ProxyCreatorService = (function() {

    function ProxyCreatorService(types, interfaceToTypeIdMapping, interfaceToGeneratedMapping) {
      var type, _i, _len;
      if (types == null) {
        types = [];
      }
      if (interfaceToTypeIdMapping == null) {
        interfaceToTypeIdMapping = new Dictionary();
      }
      if (interfaceToGeneratedMapping == null) {
        interfaceToGeneratedMapping = new Dictionary();
      }
      this.proxyTypesFromInterfaces = new Dictionary();
      this.proxyTypesFromIDs = new Dictionary();
      for (_i = 0, _len = types.length; _i < _len; _i++) {
        type = types[_i];
        if (type.isInterface) {
          this.RegisterTypeMapping(type, interfaceToGeneratedMapping.Get(type), interfaceToTypeIdMapping.Get(type));
        }
      }
    }

    ProxyCreatorService.prototype.NewObject = function(facade, instanceId, readOnly, type, typeId) {
      var proxyType;
      if ((typeId != null) && !typeId.equals(Guid.EMPTY)) {
        proxyType = this.proxyTypesFromIDs.Get(typeId);
        if (proxyType.hasOwnProperty('Initializer')) {
          proxyType.Initializer(proxyType.type.id);
        }
        return new proxyType(facade, instanceId, readOnly);
      } else {
        proxyType = this.proxyTypesFromInterfaces.Get(type);
        if (proxyType.hasOwnProperty('Initializer')) {
          proxyType.Initializer(proxyType.type.id);
        }
        return new proxyType(facade, instanceId, readOnly);
      }
    };

    ProxyCreatorService.prototype.RegisterTypeMapping = function(interfaceType, proxyType, typeId) {
      if (!interfaceType.isInterface) {
        throw "Interface type expected : " + interfaceType.name;
      }
      this.proxyTypesFromIDs.Add(typeId, proxyType);
      return this.proxyTypesFromInterfaces.Add(interfaceType, proxyType);
    };

    return ProxyCreatorService;

  })();

  window.CollectionEnumerator = (function() {

    function CollectionEnumerator(elementType, edgeEnumerator, isScalar, isReadOnly, objectInstancesService, proxyFacade) {
      this.elementType = elementType;
      this.edgeEnumerator = edgeEnumerator;
      this.isScalar = isScalar;
      this.isReadOnly = isReadOnly;
      this.objectInstancesService = objectInstancesService;
      this.proxyFacade = proxyFacade;
    }

    CollectionEnumerator.prototype.Current = function() {
      if (this.isScalar) {
        return this.objectInstancesService.GetScalarInstanceValue(this.edgeEnumerator.Current().toNodeId);
      } else {
        return this.proxyFacade.GetProxyInstance(this.isReadOnly, this.edgeEnumerator.Current().toNodeId, this.elementType);
      }
    };

    CollectionEnumerator.prototype.MoveNext = function() {
      return this.edgeEnumerator.MoveNext();
    };

    CollectionEnumerator.prototype.Reset = function() {
      return this.edgeEnumerator.Reset();
    };

    return CollectionEnumerator;

  })();

  window.DictionaryEnumerator = (function() {

    function DictionaryEnumerator() {}

    DictionaryEnumerator.prototype.construct = function(elementType, edgeEnumerator, isScalar, isReadOnly, objectInstancesService, proxyFacade) {
      this.elementType = elementType;
      this.edgeEnumerator = edgeEnumerator;
      this.isScalar = isScalar;
      this.isReadOnly = isReadOnly;
      this.objectInstancesService = objectInstancesService;
      this.proxyFacade = proxyFacade;
    };

    DictionaryEnumerator.prototype.Current = function() {
      var value;
      if (this.isScalar) {
        value = this.objectInstancesService.GetScalarInstanceValue(this.edgeEnumerator.Current.toNodeId);
      } else {
        value = this.proxyFacade.GetProxyInstance(this.isReadOnly, this.edgeEnumerator.Current().toNodeId, this.elementType);
      }
      return {
        "key": edgeEnumerator.Current().data.data,
        "value": value
      };
    };

    DictionaryEnumerator.prototype.MoveNext = function() {
      return this.edgeEnumerator.MoveNext();
    };

    DictionaryEnumerator.prototype.Reset = function() {
      return this.edgeEnumerator.Reset();
    };

    return DictionaryEnumerator;

  })();

  window.RuntimeProxyFacade = (function() {

    function RuntimeProxyFacade(typesService, objectInstancesService, immutableInstancesService, collectionInstancesService, immutableCollectionInstancesService, dictionaryInstancesService, immutableDictionaryInstancesService, mutableProxyMap, immutableProxyMap, proxyCreatorService) {
      this.typesService = typesService;
      this.objectInstancesService = objectInstancesService;
      this.immutableInstancesService = immutableInstancesService;
      this.collectionInstancesService = collectionInstancesService;
      this.immutableCollectionInstancesService = immutableCollectionInstancesService;
      this.dictionaryInstancesService = dictionaryInstancesService;
      this.immutableDictionaryInstancesService = immutableDictionaryInstancesService;
      this.mutableProxyMap = mutableProxyMap;
      this.immutableProxyMap = immutableProxyMap;
      this.proxyCreatorService = proxyCreatorService;
    }

    RuntimeProxyFacade.prototype.GetInstanceMemberValue = function(instanceId, memberId, isScalar, isReadOnly) {
      var isPermanent, referenceId, rez;
      if (instanceId.equals(Guid.EMPTY)) {
        throw "Instance was accessed outside of workspace scope or it was rolled back.";
      }
      if (isScalar) {
        if (isReadOnly) {
          return this.immutableInstancesService.GetScalarInstanceMember(instanceId, memberId);
        } else {
          return this.objectInstancesService.GetScalarInstanceMember(instanceId, memberId);
        }
      } else {
        isPermanent = false;
        referenceId = Guid.EMPTY;
        if (isReadOnly) {
          rez = this.immutableInstancesService.GetReferenceInstanceMember(instanceId, memberId);
          referenceId = rez.guid;
        } else {
          rez = this.objectInstancesService.GetReferenceInstanceMember(instanceId, memberId);
          referenceId = rez.guid;
        }
        return this.GetProxyInstance(isReadOnly || rez.isPermanet, referenceId, Guid.EMPTY);
      }
    };

    RuntimeProxyFacade.prototype.GetProxyInstance = function(isReadOnly, referenceId, typeId) {
      var collectionService, map, objectService, proxy, rez;
      if (referenceId.equals(Constants.NullReferenceNodeId)) {
        return null;
      } else {
        proxy = null;
        map = this.mutableProxyMap;
        collectionService = this.collectionInstancesService;
        objectService = this.objectInstancesService;
        if (isReadOnly) {
          map = this.immutableProxyMap;
          collectionService = this.immutableCollectionInstancesService;
          objectService = this.immutableInstancesService;
        }
        rez = map.TryGetProxy(referenceId);
        if (!rez.result) {
          if (typeId.equals(Guid.EMPTY)) {
            if (collectionService.IsCollectionInstance(referenceId)) {
              typeId = collectionService.GetInstanceTypeId(referenceId);
            } else {
              typeId = objectService.GetInstanceTypeId(referenceId);
            }
          }
          proxy = this.proxyCreatorService.NewObject(this, referenceId, isReadOnly, null, typeId);
          map.AddProxy(referenceId, proxy);
          return proxy;
        } else {
          return rez.value;
        }
      }
    };

    RuntimeProxyFacade.prototype.SetInstanceMemberValue = function(instanceId, memberId, value, isScalar, isReadOnly) {
      var referenceId;
      if (instanceId.equals(Guid.EMPTY)) {
        throw "Instance was accessed outside of workspace scope or it was rolled back.";
      }
      if (isReadOnly) {
        throw "Setting property on read only instance not allowed";
      }
      if (isScalar) {
        return this.objectInstancesService.SetScalarInstanceMember(instanceId, memberId, value);
      } else {
        referenceId = Constants.NullReferenceNodeId;
        if (value !== null) {
          if (!UTILS.HasItemId(value)) {
            throw "Object set is not a valid IOG proxy";
          }
          referenceId = UTILS.GetItemId(value);
        }
        return this.objectInstancesService.SetReferenceInstanceMember(instanceId, memberId, referenceId);
      }
    };

    RuntimeProxyFacade.prototype.CollectionAdd = function(instanceId, valueTypeId, value, isScalar) {
      return this.PerformAdd(instanceId, valueTypeId, value, isScalar, false, false);
    };

    RuntimeProxyFacade.prototype.CollectionAddOrdered = function(instanceId, valueTypeId, value, isScalar) {
      return this.PerformAdd(instanceId, valueTypeId, value, isScalar, false, true);
    };

    RuntimeProxyFacade.prototype.PerformAdd = function(instanceId, valueTypeId, value, isScalar, isSet, isOrdered) {
      var maxId, primaryKey, primaryKeyId, referenceId;
      if (instanceId.equals(Guid.EMPTY)) {
        throw "Instance was accessed outside of workspace scope or it was rolled back.";
      }
      if (isScalar) {
        if (!isSet) {
          if (isOrdered) {
            maxId = this.collectionInstancesService.MaxOrderedIdentifier(instanceId);
            return this.collectionInstancesService.AddScalar(instanceId, valueTypeId, value, maxId + 1);
          } else {
            return this.collectionInstancesService.AddScalar(instanceId, valueTypeId, value);
          }
        } else {
          return this.collectionInstancesService.AddScalar(instanceId, valueTypeId, value, value);
        }
      } else {
        referenceId = Constants.NullReferenceNodeId;
        primaryKey = null;
        if ((value != null)) {
          if (!UTILS.HasItemId(value)) {
            throw "Object set is not a valid IOG proxy";
          }
          referenceId = UTILS.GetItemId(value);
          primaryKeyId = UTILS.GetItemPrimaryKeyId(value);
          if (!primaryKeyId.equals(Guid.EMPTY)) {
            primaryKey = this.objectInstancesService.GetScalarInstanceMember(referenceId, primaryKeyId);
          }
          if (isOrdered) {
            maxId = this.collectionInstancesService.MaxOrderedIdentifier(instanceId);
            return this.collectionInstancesService.AddReference(instanceId, referenceId, maxId + 1);
          } else {
            if (!(primaryKey != null)) {
              return this.collectionInstancesService.AddReference(instanceId, referenceId);
            } else {
              return this.collectionInstancesService.AddReference(instanceId, referenceId, primaryKey);
            }
          }
        }
      }
    };

    RuntimeProxyFacade.prototype.CollectionClear = function(instanceId) {
      if (instanceId.equals(Guid.EMPTY)) {
        throw "Instance was accessed outside of workspace scope or it was rolled back.";
      }
      this.collectionInstancesService.Clear(instanceId);
    };

    RuntimeProxyFacade.prototype.CollectionContains = function(instanceId, value, isScalar, isReadOnly) {
      return this.PerformContains(instanceId, value, isScalar, false, isReadOnly, false);
    };

    RuntimeProxyFacade.prototype.CollectionContainsOrdered = function(instanceId, value, isScalar, isReadOnly) {
      return this.PerformContains(instanceId, value, isScalar, false, isReadOnly, true);
    };

    RuntimeProxyFacade.prototype.PerformContains = function(instanceId, value, isScalar, isSet, isReadOnly, isOrdered) {
      var primaryKey, primaryKeyId, referenceId, service;
      if (instanceId.equals(Guid.EMPTY)) {
        throw "Instance was accessed outside of workspace scope or it was rolled back.";
      }
      service = this.collectionInstancesService;
      if (isReadOnly) {
        service = this.immutableCollectionInstancesService;
      }
      if (isScalar) {
        if (!isSet) {
          return service.ContainsScalar(instanceId, value);
        } else {
          return service.ContainsScalar(instanceId, value, value);
        }
      } else {
        referenceId = Constants.NullReferenceNodeId;
        primaryKey = null;
        if ((value != null)) {
          if (!UTILS.HasItemId(value)) {
            throw "Object set is not a valid IOG proxy";
          }
          referenceId = UTILS.GetItemId(value);
          primaryKeyId = UTILS.GetItemPrimaryKeyId(value);
          if (!primaryKeyId.equals(Guid.EMPTY)) {
            primaryKey = this.objectInstancesService.GetScalarInstanceMember(referenceId, primaryKeyId);
          }
        }
        if (primaryKey === null || isOrdered) {
          return service.ContainsReference(instanceId, referenceId);
        } else {
          return service.ContainsReference(instanceId, referenceId, primaryKey);
        }
      }
    };

    RuntimeProxyFacade.prototype.CollectionCopyTo = function(elementTypeId, instanceId, isScalar, isReadOnly, array, arrayIndex) {
      var enumerator, index, _results;
      if (instanceId.equals(Guid.EMPTY)) {
        throw "Instance was accessed outside of workspace scope or it was rolled back.";
      }
      enumerator = this.CollectionGetEnumerator(elementTypeId, instanceId, isScalar, isReadOnly);
      index = arrayIndex;
      _results = [];
      while (enumerator.MoveNext()) {
        array.SetValue(enumerator.Current, index);
        _results.push(index++);
      }
      return _results;
    };

    RuntimeProxyFacade.prototype.CollectionCount = function(instanceId) {
      if (instanceId.equals(Guid.EMPTY)) {
        throw "Instance was accessed outside of workspace scope or it was rolled back.";
      }
      return this.collectionInstancesService.Count(instanceId);
    };

    RuntimeProxyFacade.prototype.CollectionRemove = function(instanceId, value, isScalar) {
      return this.PerformRemove(instanceId, value, isScalar, false, false);
    };

    RuntimeProxyFacade.prototype.CollectionRemoveOrdered = function(instanceId, value, isScalar) {
      return this.PerformRemove(instanceId, value, isScalar, false, true);
    };

    RuntimeProxyFacade.prototype.PerformRemove = function(instanceId, value, isScalar, isSet, isOrdered) {
      var primaryKey, primaryKeyId, referenceId;
      if (instanceId.equals(Guid.EMPTY)) {
        throw "Invalid instance revision ID";
      }
      if (isScalar) {
        if (!isSet) {
          return this.collectionInstancesService.RemoveScalar(instanceId, value);
        } else {
          return this.collectionInstancesService.RemoveScalar(instanceId, value, value);
        }
      } else {
        referenceId = Constants.NullReferenceNodeId;
        primaryKey = null;
        if (value !== null) {
          if (!Utils.HasItemId(value)) {
            throw "Object set is not a valid IOG proxy";
          }
          referenceId = UTILS.GetItemId(value);
          primaryKeyId = UTILS.GetItemPrimaryKeyId(value);
          if (!primaryKeyId.equals(Guid.EMPTY)) {
            primaryKey = this.objectInstancesService.GetScalarInstanceMember(referenceId, primaryKeyId);
          }
        }
        if (primaryKey === null || isOrdered) {
          return this.collectionInstancesService.RemoveReference(instanceId, referenceId);
        } else {
          return this.collectionInstancesService.RemoveReference(instanceId, referenceId, primaryKey);
        }
      }
    };

    RuntimeProxyFacade.prototype.IsScalarType = function(typeId) {
      return this.typesService.IsScalarType(typeId);
    };

    RuntimeProxyFacade.prototype.GetTypeId = function(type) {
      return this.typesService.GetTypeId(type);
    };

    RuntimeProxyFacade.prototype.CollectionGetEnumerator = function(elementType, instanceId, isScalar, isReadOnly) {
      var enumeration, var1, var2;
      if (isReadOnly) {
        var1 = this.immutableCollectionInstancesService.GetEnumerator(instanceId);
      } else {
        var1 = this.collectionInstancesService.GetEnumerator(instanceId);
      }
      if (isReadOnly) {
        var2 = this.immutableInstancesService;
      } else {
        var2 = this.objectInstancesService;
      }
      enumeration = new CollectionEnumerator(elementType, var1, isScalar, isReadOnly, var2, this);
      return enumeration;
    };

    RuntimeProxyFacade.prototype.CollectionTryFindPrimaryKey = function(elementType, instanceId, isScalar, isReadOnly, key) {
      var referenceId, rez, value;
      referenceId = Guid.EMPTY;
      rez = this.collectionInstancesService.TryFindReferenceByKey(instanceId, key);
      if (rez.result) {
        value = this.GetProxyInstance(isReadOnly, referenceId, elementType);
        return {
          "result": true,
          "value": value
        };
      } else {
        return {
          "result": false,
          "value": UTILS.Default(value)
        };
      }
    };

    RuntimeProxyFacade.prototype.CollectionFindByPrimaryKey = function(elementType, instanceId, isScalar, isReadOnly, key) {
      var referenceId, rez;
      referenceId = Guid.EMPTY;
      rez = this.collectionInstancesService.TryFindReferenceByKey(instanceId, key);
      if (rez.result) {
        return this.GetProxyInstance(isReadOnly, rez.value, elementType);
      } else {
        throw "Key not found";
      }
    };

    RuntimeProxyFacade.prototype.CollectionContainsPrimaryKey = function(instanceId, key, isReadOnly) {
      var referenceId;
      referenceId = Guid.EMPTY;
      if (isReadOnly) {
        return this.immutableCollectionInstancesService.TryFindReferenceByKey(instanceId, key).result;
      } else {
        return this.collectionInstancesService.TryFindReferenceByKey(instanceId, key).result;
      }
    };

    RuntimeProxyFacade.prototype.DictionaryAdd = function(instanceId, elementType, isScalar, key, value) {
      var referenceId;
      if (instanceId.equals(Guid.EMPTY)) {
        throw "Instance was accessed outside of workspace scope or it was rolled back.";
      }
      if (isScalar) {
        return this.dictionaryInstancesService.AddScalar(instanceId, elementType, key, value);
      } else {
        referenceId = Constants.NullReferenceNodeId;
        if (value !== null) {
          if (!UTILS.HasItemId(value)) {
            throw "Object set is not a valid IOG proxy";
          }
          referenceId = UTILS.GetItemId(value);
        }
        return this.dictionaryInstancesService.AddReference(instanceId, key, referenceId);
      }
    };

    RuntimeProxyFacade.prototype.DictionaryContainsKey = function(instanceId, key, readOnly) {
      if (readOnly) {
        return this.immutableDictionaryInstancesService.Contains(instanceId, key);
      } else {
        return this.dictionaryInstancesService.ContainsKey(instanceId, key);
      }
    };

    RuntimeProxyFacade.prototype.DictionaryKeys = function(instanceId, readOnly) {
      var enumerator, keys, service;
      service = this.dictionaryInstancesService;
      if (readOnly) {
        service = this.immutableDictionaryInstancesService;
      }
      keys = [];
      enumerator = service.GetEnumerator(instanceId);
      while (enumerator.MoveNext()) {
        keys.Add(enumerator.Current().data.data);
      }
      return keys;
    };

    RuntimeProxyFacade.prototype.DictionaryRemove = function(instanceId, key) {
      return this.dictionaryInstancesService.Remove(instanceId, key);
    };

    RuntimeProxyFacade.prototype.DictionaryTryGetValue = function(instanceId, elementTypeId, isSclar, readOnly, key, type) {
      var referenceId, rez, value;
      if (isSclar) {
        rez = this.dictionaryInstancesService.TryGetScalar(instanceId, key);
        return rez;
      } else {
        referenceId = Guid.EMPTY;
        value = UTILS.Default(type);
        rez = this.dictionaryInstancesService.TryGetReference(instanceId, key);
        if (rez.result) {
          value = this.GetProxyInstance(readOnly, rez.value, elementTypeId);
          return {
            "result": true,
            "value": value
          };
        } else {
          return {
            "result": false,
            "value": null
          };
        }
      }
    };

    RuntimeProxyFacade.prototype.DictionaryValues = function(instanceId, elementTypeId, isSclar, readOnly) {
      var enumerator, values;
      values = [];
      enumerator = this.dictionaryInstancesService.GetEnumerator(instanceId);
      while (enumerator.MoveNext()) {
        values.Add(this.DictionaryGetValue(instanceId, elementTypeId, isSclar, readOnly, enumerator.Current().data.data));
      }
      return values;
    };

    RuntimeProxyFacade.prototype.DictionaryGetValue = function(instanceId, elementTypeId, isSclar, readOnly, key) {
      var referenceId, rez, scalarValue;
      if (isSclar) {
        rez = this.dictionaryInstancesService.TryGetScalar(instanceId, key);
        scalarValue = null;
        if (rez.result) {
          return rez.value;
        } else {
          throw "Element not found with given key";
        }
      } else {
        referenceId = Guid.EMPTY;
        rez = this.dictionaryInstancesService.TryGetReference(instanceId, key);
        if (rez.result) {
          return this.GetProxyInstance(readOnly, referenceId, elementTypeId);
        } else {
          throw "Element not found with given key";
        }
      }
    };

    RuntimeProxyFacade.prototype.DictionarySetValue = function(instanceId, elementTypeId, isSclar, readOnly, key, value) {
      if (isSclar) {
        return this.dictionaryInstancesService.SetScalar(instanceId, elementTypeId, key, value);
      } else {
        if (!UTILS.HasItemId(value)) {
          throw "Object set is not a valid IOG proxy";
        }
        return this.dictionaryInstancesService.SetReference(instanceId, key, UTILS.GetItemId(value));
      }
    };

    RuntimeProxyFacade.prototype.DictionaryAdd = function(instanceId, elementTypeId, isScalar, item) {
      if (hasOwnProperty(item, "value") || hasOwnProperty(item, "key")) {
        this.DictionaryAdd(instanceId, elementTypeId, isScalar, item.key, item.value);
        return;
      }
    };

    RuntimeProxyFacade.prototype.DictionaryClear = function(instanceId) {
      this.dictionaryInstancesService.Clear(instanceId);
    };

    RuntimeProxyFacade.prototype.DictionaryContains = function(instanceId, item, readOnly) {
      if (readOnly) {
        return this.immutableDictionaryInstancesService.ContainsKey(instanceId, item.key);
      } else {
        return this.dictionaryInstancesService.ContainsKey(instanceId, item.key);
      }
    };

    RuntimeProxyFacade.prototype.DictionaryCopyTo = function(instanceId, elementTypeId, isSclar, readOnly, array, arrayIndex) {
      var enumerator, index, key;
      index = arrayIndex;
      enumerator = this.dictionaryInstancesService.GetEnumerator(instanceId);
      while (enumerator.MoveNext()) {
        key = enumerator.Current().data.data;
        array[arrayIndex] = {
          "key": key,
          "value": this.DictionaryGetValue(instanceId, elementTypeId, isSclar, readOnly, key)
        };
        arrayIndex++;
        return;
      }
    };

    RuntimeProxyFacade.prototype.DictionaryCount = function(instanceId, readOnly) {
      if (readOnly) {
        return this.immutableDictionaryInstancesService.Count(instanceId);
      } else {
        return this.dictionaryInstancesService.Count(instanceId);
      }
    };

    RuntimeProxyFacade.prototype.DictionaryRemove = function(instanceId, item) {
      return this.dictionaryInstancesService.Remove(instanceId, item.key);
    };

    RuntimeProxyFacade.prototype.DictionaryGetEnumerator = function(instanceId, elementTypeId, isSclar, readOnly) {
      var val1, val2;
      if (readOnly) {
        val1 = this.immutableDictionaryInstancesService.GetEnumerator(instanceId);
      } else {
        val1 = this.dictionaryInstancesService.GetEnumerator(instanceId);
      }
      if (readOnly) {
        val2 = this.immutableInstancesService;
      } else {
        val2 = this.objectInstancesService;
      }
      return new DictionaryEnumerator(elementTypeId, val1, isSclar, readOnly, val2, this);
    };

    RuntimeProxyFacade.prototype.SetAdd = function(instanceId, itemTypeId, item, isScalar) {
      this.PerformAdd(instanceId, itemTypeId, item, isScalar, true, false);
    };

    RuntimeProxyFacade.prototype.SetContains = function(instanceId, item, isScalar, isReadOnly) {
      return this.PerformContains(instanceId, item, isScalar, true, isReadOnly, false);
    };

    RuntimeProxyFacade.prototype.SetRemove = function(instanceId, item, isScalar) {
      return this.PerformRemove(instanceId, item, isScalar, true, false);
    };

    return RuntimeProxyFacade;

  })();

  window.StaticProxyFacade = (function() {
    var _instance;

    function StaticProxyFacade() {}

    _instance = void 0;

    StaticProxyFacade.get = function() {
      if (_instance === void 0 || _instance === null) {
        throw "ProxyFacade not initialized";
      }
      return _instance;
    };

    StaticProxyFacade.Initialize = function(typesService) {
      var inst;
      if (typesService === null) {
        throw "typesService";
      }
      inst = new _StaticProxyFacade();
      inst.typesService = typesService;
      return _instance = inst;
    };

    return StaticProxyFacade;

  })();

  _StaticProxyFacade = (function() {

    function _StaticProxyFacade() {
      this.typesService = null;
    }

    _StaticProxyFacade.prototype.GetTypeId = function(type) {
      return this.typesService.GetTypeIdCached(type);
    };

    _StaticProxyFacade.prototype.GetTypeMemberId = function(typeId, propertyName) {
      return this.typesService.GetTypeMemberId(typeId, propertyName);
    };

    _StaticProxyFacade.prototype.IsScalarType = function(typeId) {
      return this.typesService.IsScalarType(typeId);
    };

    _StaticProxyFacade.prototype.IsScalarMember = function(memberId) {
      var typeId;
      typeId = this.typesService.GetMemberTypeId(memberId);
      return this.typesService.IsScalarType(typeId);
    };

    _StaticProxyFacade.prototype.GetTypePrimaryKeyMemberId = function(typeId) {
      return this.typesService.GetTypePrimaryKeyMemberId(typeId);
    };

    _StaticProxyFacade.prototype.AreEqual = function(proxy1, proxy2) {
      if (proxy2 === null) {
        return false;
      }
      if (!UTILS.HasItemId(proxy2)) {
        return false;
      }
      return UTILS.GetItemId(proxy1).equals(UTILS.GetItemId(proxy2));
    };

    _StaticProxyFacade.prototype.GetProxyHashCode = function(instance) {
      return UTILS.GetItemId(instance).GetHashCode();
    };

    return _StaticProxyFacade;

  })();

  window.CollectionProxy = (function() {

    function CollectionProxy(__facade__, __instanceId__, __readOnly__, type) {
      this.__facade__ = __facade__;
      this.__instanceId__ = __instanceId__;
      this.__readOnly__ = __readOnly__;
      this.type = type;
      this.elementTypeId = StaticProxyFacade.get().GetTypeId(this.type);
      this.isScalar = StaticProxyFacade.get().IsScalarType(this.elementTypeId);
    }

    CollectionProxy.prototype.Add = function(item) {
      if (this.__readOnly__) {
        throw "Operation not allowed for read only collection";
      }
      return this.__facade__.CollectionAdd(this.__instanceId__, Guid.EMPTY, item, this.isScalar);
    };

    CollectionProxy.prototype.Clear = function() {
      if (this.__readOnly__) {
        throw "Operation not allowed for read only collection";
      }
      return this.__facade__.CollectionClear(this.__instanceId__);
    };

    CollectionProxy.prototype.Contains = function(item) {
      return this.__facade__.CollectionContains(this.__instanceId__, item, this.isScalar, this.__readOnly__);
    };

    CollectionProxy.prototype.CopyTo = function(array, arrayIndex) {
      this.__facade__.CollectionCopyTo(Guid.EMPTY, this.__instanceId__, this.isScalar, this.__readOnly__, array, arrayIndex);
    };

    CollectionProxy.prototype.Count = function() {
      return this.__facade__.CollectionCount(this.__instanceId__);
    };

    CollectionProxy.prototype.IsReadOnly = function() {
      return retunr(this.__readOnly__);
    };

    CollectionProxy.prototype.Remove = function(item) {
      if (this.__readOnly__) {
        throw "Operation not allowed for read only collection";
      }
      return this.__facade__.CollectionRemove(this.__instanceId__, item, this.isScalar);
    };

    CollectionProxy.prototype.GetEnumerator = function() {
      return this.__facade__.CollectionGetEnumerator(Guid.EMPTY, this.__instanceId__, this.isScalar, this.__readOnly__);
    };

    CollectionProxy.prototype.TryFindPrimaryKey = function(key) {
      var rez;
      rez = this.__facade__.CollectionTryFindPrimaryKey(Guid.EMPTY, this.__instanceId__, this.isScalar, this.IsReadOnly(), key);
      return rez.result;
    };

    CollectionProxy.prototype.FindByPrimaryKey = function(key) {
      return this.__facade__.CollectionFindByPrimaryKey(Guid.EMPTY, this.__instanceId__, this.isScalar, this.IsReadOnly(), key);
    };

    CollectionProxy.prototype.ContainsPrimaryKey = function(key) {
      return this.__facade__.CollectionContainsPrimaryKey(this.__instanceId__, key, this.__readOnly__);
    };

    return CollectionProxy;

  })();

  window.CollectionProxySealed = (function() {

    function CollectionProxySealed(__facade__, __instanceId__, __readOnly__, type) {
      this.__facade__ = __facade__;
      this.__instanceId__ = __instanceId__;
      this.__readOnly__ = __readOnly__;
      this.type = type;
      this.elementTypeId = StaticProxyFacade.get().GetTypeId(this.type);
      this.isScalar = StaticProxyFacade.get().IsScalarType(this.elementTypeId);
    }

    CollectionProxySealed.prototype.Add = function(item) {
      if (this.__readOnly__) {
        throw "Operation not allowed for read only collection";
      }
      return this.__facade__.CollectionAdd(this.__instanceId__, this.elementTypeId, item, this.isScalar);
    };

    CollectionProxySealed.prototype.Clear = function() {
      if (this.__readOnly__) {
        throw "Operation not allowed for read only collection";
      }
      this.__facade__.CollectionClear(this.__instanceId__);
    };

    CollectionProxySealed.prototype.Contains = function(item) {
      return this.__facade__.CollectionContains(this.__instanceId__, item, this.isScalar, this.__readOnly__);
    };

    CollectionProxySealed.prototype.CopyTo = function(array, arrayIndex) {
      this.__facade__.CollectionCopyTo(this.elementTypeId, this.__instanceId__, this.isScalar, this.__readOnly__, array, arrayIndex);
    };

    CollectionProxySealed.prototype.Count = function() {
      return this.__facade__.CollectionCount(this.__instanceId__);
    };

    CollectionProxySealed.prototype.IsReadOnly = function() {
      return this.__readOnly__;
    };

    CollectionProxySealed.prototype.Remove = function(item) {
      if (this.__readOnly__) {
        throw "Operation not allowed for read only collection";
      }
      return this.__facade__.CollectionRemove(this.__instanceId__, item, this.isScalar);
    };

    CollectionProxySealed.prototype.GetEnumerator = function() {
      return this.__facade__.CollectionGetEnumerator(this.elementTypeId, this.__instanceId__, this.isScalar, this.__readOnly__);
    };

    CollectionProxySealed.prototype.TryFindPrimaryKey = function(key) {
      var rez;
      rez = this.__facade__.CollectionTryFindPrimaryKey(this.elementTypeId, this.__instanceId__, this.isScalar, this.IsReadOnly(), key);
      return rez.result;
    };

    CollectionProxySealed.prototype.FindByPrimaryKey = function(key) {
      return this.__facade__.CollectionFindByPrimaryKey(this.elementTypeId, this.__instanceId__, this.isScalar, this.IsReadOnly(), key);
    };

    CollectionProxySealed.prototype.ContainsPrimaryKey = function(key) {
      return this.__facade__.CollectionContainsPrimaryKey(this.__instanceId__, key, this.__readOnly__);
    };

    return CollectionProxySealed;

  })();

  window.DictionaryProxy = (function() {

    function DictionaryProxy(__facade__, __instanceId__, __readOnly__, type) {
      this.__facade__ = __facade__;
      this.__instanceId__ = __instanceId__;
      this.__readOnly__ = __readOnly__;
      this.type = type;
      this.elementTypeId = StaticProxyFacade.Instance.GetTypeId(this.type);
      this.isScalar = StaticProxyFacade.Instance.IsScalarType(this.elementTypeId);
    }

    DictionaryProxy.prototype.Add = function(key, value) {
      if (this.__readOnly__) {
        throw "Operation not allowed for read only dictionary";
      }
      return facade.DictionaryAdd(this.__instanceId__, Guid.EMPTY, this.isScalar, key, value);
    };

    DictionaryProxy.prototype.ContainsKey = function(key) {
      return this.__facade__.DictionaryContainsKey(this.__instanceId__, key, this.__readOnly__);
    };

    DictionaryProxy.prototype.Keys = function() {
      return this.__facade__.DictionaryKeys(this.__instanceId__, this.__readOnly__);
    };

    DictionaryProxy.prototype.Remove = function(key) {
      if (__readOnly__) {
        throw "Operation not allowed for read only dictionary";
        return this.__facade__.DictionaryRemove(this.__instanceId__, key);
      }
    };

    DictionaryProxy.prototype.TryGetValue = function(key) {
      return this.__facade__.DictionaryTryGetValue(this.__instanceId__, Guid.EMPTY, this.isScalar, this.__readOnly__, key);
    };

    DictionaryProxy.prototype.Values = function() {
      return this.__facade__.DictionaryValues(this.__instanceId__, Guid.EMPTY, this.isScalar, this.__readOnly__);
    };

    DictionaryProxy.prototype.Get = function(key) {
      return this.__facade__.DictionaryGetValue(this.__instanceId__, Guid.EMPTY, this.isScalar, this.__readOnly__, key);
    };

    DictionaryProxy.prototype.Set = function(key, value) {
      if (this.__readOnly__) {
        throw "Operation not allowed for read only dictionary";
      }
      return this.__facade__.DictionarySetValue(this.__instanceId__, Guid.EMPTY, this.isScalar, this.__readOnly__, key, value);
    };

    DictionaryProxy.prototype.Add = function(item) {
      return this.__facade__.DictionaryAdd(this.__instanceId__, Guid.EMPTY, this.isScalar, item);
    };

    DictionaryProxy.prototype.Clear = function() {
      if (__readOnly__) {
        throw "Operation not allowed for read only dictionary";
      }
      this.__facade__.DictionaryClear(this.__instanceId__);
    };

    DictionaryProxy.prototype.Contains = function(item) {
      return this.__facade__.DictionaryContains(this.__instanceId__, item, this.__readOnly__);
    };

    DictionaryProxy.prototype.CopyTo = function(array, arrayIndex) {
      this.__facade__.DictionaryCopyTo(this.__instanceId__, Guid.EMPTY, this.isScalar, this.__readOnly__, array, arrayIndex);
    };

    DictionaryProxy.prototype.Count = function() {
      return this.__facade__.DictionaryCount(this.__instanceId__, this.__readOnly__);
    };

    DictionaryProxy.prototype.IsReadOnly = function() {
      return this.__readOnly__;
    };

    DictionaryProxy.prototype.Remove = function(item) {
      if (this.__readOnly__) {
        throw "Operation not allowed for read only dictionary";
      }
      return this.__facade__.DictionaryRemove(this.__instanceId__, item);
    };

    DictionaryProxy.prototype.GetEnumerator = function() {
      return this.__facade__.DictionaryGetEnumerator(this.__instanceId__, Guid.EMPTY, this.isScalar, this.readOnly);
    };

    return DictionaryProxy;

  })();

  window.DictionaryProxySealed = (function() {

    function DictionaryProxySealed(__facade__, __instanceId__, __readOnly__, type) {
      this.__facade__ = __facade__;
      this.__instanceId__ = __instanceId__;
      this.__readOnly__ = __readOnly__;
      this.type = type;
      this.elementTypeId = StaticProxyFacade.Instance.GetTypeId(this.type);
      this.isScalar = StaticProxyFacade.Instance.IsScalarType(this.elementTypeId);
    }

    DictionaryProxySealed.prototype.Add = function(key, value) {
      if (this.__readOnly__) {
        throw "Operation not allowed for read only dictionary";
      }
      return facade.DictionaryAdd(this.__instanceId__, this.lementTypeId, this.isScalar, key, value);
    };

    DictionaryProxySealed.prototype.ContainsKey = function(key) {
      return this.__facade__.DictionaryContainsKey(this.__instanceId__, key, this.__readOnly__);
    };

    DictionaryProxySealed.prototype.Keys = function() {
      return this.__facade__.DictionaryKeys(this.__instanceId__, this.__readOnly__);
    };

    DictionaryProxySealed.prototype.Remove = function(key) {
      if (__readOnly__) {
        throw "Operation not allowed for read only dictionary";
      }
      return this.__facade__.DictionaryRemove(this.__instanceId__, key);
    };

    DictionaryProxySealed.prototype.TryGetValue = function(key) {
      return this.__facade__.DictionaryTryGetValue(this.__instanceId__, this.lementTypeId, this.isScalar, this.__readOnly__, key);
    };

    DictionaryProxySealed.prototype.Values = function() {
      return this.__facade__.DictionaryValues(this.__instanceId__, this.lementTypeId, this.isScalar, this.__readOnly__);
    };

    DictionaryProxySealed.prototype.Get = function(key) {
      return this.__facade__.DictionaryGetValue(this.__instanceId__, this.lementTypeId, this.isScalar, this.__readOnly__, key);
    };

    DictionaryProxySealed.prototype.Set = function(key, value) {
      if (this.__readOnly__) {
        throw "Operation not allowed for read only dictionary";
      }
      return this.__facade__.DictionarySetValue(this.__instanceId__, this.lementTypeId, this.isScalar, this.__readOnly__, key, value);
    };

    DictionaryProxySealed.prototype.Add = function(item) {
      return this.__facade__.DictionaryAdd(this.__instanceId__, this.lementTypeId, this.isScalar, item);
    };

    DictionaryProxySealed.prototype.Clear = function() {
      if (__readOnly__) {
        throw "Operation not allowed for read only dictionary";
      }
      this.__facade__.DictionaryClear(this.__instanceId__);
    };

    DictionaryProxySealed.prototype.Contains = function(item) {
      return this.__facade__.DictionaryContains(this.__instanceId__, item, this.__readOnly__);
    };

    DictionaryProxySealed.prototype.CopyTo = function(array, arrayIndex) {
      this.__facade__.DictionaryCopyTo(this.__instanceId__, this.lementTypeId, this.isScalar, this.__readOnly__, array, arrayIndex);
    };

    DictionaryProxySealed.prototype.Count = function() {
      return this.__facade__.DictionaryCount(this.__instanceId__, this.__readOnly__);
    };

    DictionaryProxySealed.prototype.IsReadOnly = function() {
      return this.__readOnly__;
    };

    DictionaryProxySealed.prototype.Remove = function(item) {
      if (this.__readOnly__) {
        throw "Operation not allowed for read only dictionary";
      }
      return this.__facade__.DictionaryRemove(this.__instanceId__, item);
    };

    DictionaryProxySealed.prototype.GetEnumerator = function() {
      return this.__facade__.DictionaryGetEnumerator(this.__instanceId__, this.lementTypeId, this.isScalar, this.__readOnly__);
    };

    return DictionaryProxySealed;

  })();

  window.FieldBuilder = (function() {

    function FieldBuilder(fieldName, fieldType) {
      this.fieldName = fieldName;
      this.fieldType = fieldType;
    }

    return FieldBuilder;

  })();

  window.ProxyBuilder = (function() {

    ProxyBuilder.IOG_TYPE = "iogType";

    function ProxyBuilder() {}

    ProxyBuilder.Generate = function(className, properties, type) {
      var C;
      C = eval("(function() {function " + className + "(facade, instanceId, readOnly) {this." + Constants.FacadeFieldName + " = facade; this." + Constants.InstanceIdFieldName + " = instanceId; this." + Constants.ReadOnlyFieldName + " = readOnly;}; " + className + ".name = " + className + "; return " + className + ";})();");
      C.prototype["Equals"] = function() {
        return StaticProxyFacade.get().AreEqual(this, obj);
      };
      C.prototype["GetHashCode"] = function() {
        return StaticProxyFacade.get().GetProxyHashCode(this);
      };
      C.primaryKeyMemberId = null;
      C.propertyIdName = null;
      C.propertyIsScalarName = null;
      C.typeId = null;
      C.type = type;
      C["Initializer"] = function() {
        var prop, propMemberIdSufix, propMemberIsScalarSufix, proxyFacade, _i, _len;
        C.typeId = type.id;
        proxyFacade = StaticProxyFacade.get();
        C.typeId = proxyFacade.typesService.GetTypeId(C.type);
        C.primaryKeyMemberId = proxyFacade.GetTypePrimaryKeyMemberId(C.typeId);
        for (_i = 0, _len = properties.length; _i < _len; _i++) {
          prop = properties[_i];
          if (ProxyBuilder.IsRevisionIdProperty(prop)) {
            throw "Unknow code";
          } else {
            if (ProxyBuilder.IsDataProperty(prop)) {
              C[prop.name + Constants.PropertyMemberIdSufix] = proxyFacade.GetTypeMemberId(C.typeId, new IOGString(prop.name));
              C[prop.name + Constants.PropertyIsScalarSufix] = proxyFacade.IsScalarMember(C[prop.name + Constants.PropertyMemberIdSufix]);
              propMemberIdSufix = C[prop.name + Constants.PropertyMemberIdSufix].value;
              propMemberIsScalarSufix = C[prop.name + Constants.PropertyIsScalarSufix];
              if (propMemberIsScalarSufix === true) {
                C.prototype["Set" + prop.name] = eval("(function(value) {this." + Constants.FacadeFieldName + ".SetInstanceMemberValue(this." + Constants.InstanceIdFieldName + ",  new Guid('" + propMemberIdSufix + "'), IOGType.CreateScalar( UTILS.GetType('" + (prop.GetPropertyType().name) + "'), value), " + propMemberIsScalarSufix + ", this." + Constants.ReadOnlyFieldName + ");})");
                C.prototype["Get" + prop.name] = eval("(function() {var value = this." + Constants.FacadeFieldName + ".GetInstanceMemberValue(this." + Constants.InstanceIdFieldName + ", new Guid('" + propMemberIdSufix + "'), " + propMemberIsScalarSufix + ", this." + Constants.ReadOnlyFieldName + "); if(value == null) return null; else return value.value;})");
              } else {
                C.prototype["Set" + prop.name] = eval("(function(value) {this." + Constants.FacadeFieldName + ".SetInstanceMemberValue(this." + Constants.InstanceIdFieldName + ",  new Guid('" + propMemberIdSufix + "'), value, " + propMemberIsScalarSufix + ", this." + Constants.ReadOnlyFieldName + ");})");
                C.prototype["Get" + prop.name] = eval("(function() {return this." + Constants.FacadeFieldName + ".GetInstanceMemberValue(this." + Constants.InstanceIdFieldName + ", new Guid('" + propMemberIdSufix + "'), " + propMemberIsScalarSufix + ", this." + Constants.ReadOnlyFieldName + ");})");
              }
            }
          }
        }
        C.prototype["equals"] = function(object) {
          return StaticProxyFacade.get().AreEqual(this, obj);
        };
        return C.prototype["GetHashCode"] = function() {
          return StaticProxyFacade.get().GetProxyHashCode(this);
        };
      };
      return C;
    };

    ProxyBuilder.IsRevisionIdProperty = function(propertyInfo) {
      return propertyInfo.canRead && !propertyInfo.canWrite && propertyInfo.GetCustomAttributes("RevisionIdAttribute") && propertyInfo.GetPropertyType().equals(GuidType);
    };

    ProxyBuilder.IsDataProperty = function(propertyInfo) {
      return propertyInfo.canRead && propertyInfo.canWrite;
    };

    return ProxyBuilder;

  })();

  window.TypeBuilder = (function() {

    function TypeBuilder() {}

    TypeBuilder.DefineType = function(typeName) {
      return new Type(Guid.Create(), typeName, false, false, false, false, false, null, []);
    };

    return TypeBuilder;

  })();

  window.GenerationService = (function() {

    function GenerationService(typesService) {
      this.typesService = typesService;
    }

    GenerationService.AddEqualsHashcode = function(tb) {};

    GenerationService.GenerateDataProperty = function(tb, property, propertyName, fbinstaceId, fbTypeId, fbReadOnly, fbFacade) {
      throw "Changed implementation";
    };

    GenerationService.GenerateRevisionIdProperty = function(tb, property, fbinstaceId) {
      throw "Changed implementation";
    };

    GenerationService.prototype.GenerateProxyType = function(type) {
      var assemblyFileName, collectionType, dictionaryType, newType, properties, saveAssemblyToDisk, typeId;
      saveAssemblyToDisk = false;
      assemblyFileName = "a";
      dictionaryType = null;
      if (((dictionaryType = UTILS.IsDictionaryType(type)) != null)) {
        return this.GenerateDictionaryProxyType(type);
      }
      collectionType = null;
      if (((collectionType = UTILS.IsCollectionType(type)) != null)) {
        return this.GenerateCollectionProxyType(type);
      }
      if (!type.isInterface) {
        throw "Type should be an interface:" + type.name;
      }
      typeId = this.typesService.GetTypeId(type);
      if (typeId.equals(Guid.EMPTY)) {
        throw "Type not registered:" + type.name;
      }
      properties = [];
      UTILS.ExtractProperties(type, properties);
      newType = ProxyBuilder.Generate(type.name + Constants.ProxyTypeSufix, properties, type);
      return newType;
    };

    GenerationService.prototype.IsRevisionIdProperty = function(propertyInfo) {
      return propertyInfo.canRead && !propertyInfo.canWrite && propertyInfo.GetCustomAttributes(RevisionIdAttribute) && propertyInfo.GetPropertyType().equals(GuidType);
    };

    GenerationService.prototype.IsDataProperty = function(propertyInfo) {
      return propertyInfo.canRead && propertyInfo.canWrite;
    };

    GenerationService.prototype.GenerateCollectionProxyType = function(collectionType) {
      var baseListType, elementType, inter, isOrdered, isSet, _i, _len, _ref;
      elementType = collectionType.genericArguments;
      baseListType = null;
      isSet = false;
      isOrdered = false;
      _ref = collectionType.interfaces;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        inter = _ref[_i];
        if (inter === "IScalarSet") {
          isSet = true;
        }
        if (inter === "IOrderedCollection") {
          isOrdered = true;
        }
      }
      if (!this.typesService.IsSealedType(elementType)) {
        if (!isSet) {
          if (isOrdered) {
            throw "Not yet supported";
          } else {
            baseListType = CollectionProxy;
          }
        } else {
          throw "Not yet supported";
        }
      } else {
        if (!isSet) {
          if (isOrdered) {
            throw "Not yet supported";
          } else {
            baseListType = CollectionProxySealed;
          }
        } else {
          throw "Not yet supported";
        }
      }
      return baseListType;
    };

    GenerationService.prototype.GenerateDictionaryProxyType = function(dictionaryType) {
      var baseDictionaryType, elementType;
      elementType = dictionaryType.genericType;
      if (!this.typesService.IsSealedType(elementType[0])) {
        baseDictionaryType = DictionaryProxy;
      } else {
        baseDictionaryType = DictionaryProxySealed;
      }
      return baseDictionaryType;
    };

    GenerationService.prototype.GenerateProxyTypes = function(types) {
      var assemblyFileName, generatedType, mapping, saveAssemblyToDisk, type, _i, _len;
      saveAssemblyToDisk = false;
      assemblyFileName = "a";
      mapping = new Dictionary();
      for (_i = 0, _len = types.length; _i < _len; _i++) {
        type = types[_i];
        if (type.isInterface) {
          generatedType = this.GenerateProxyType(type);
          mapping.Add(type, generatedType);
        }
      }
      return mapping;
    };

    return GenerationService;

  })();

  TypeMergeRule = (function() {

    function TypeMergeRule(isConcurrent, isStaticConcurrency, dynamicResolverType, isMemberOverride) {
      this.isConcurrent = isConcurrent;
      this.isStaticConcurrency = isStaticConcurrency;
      this.dynamicResolverType = dynamicResolverType;
      this.isMemberOverride = isMemberOverride != null ? isMemberOverride : new Dictionary();
    }

    return TypeMergeRule;

  })();

  window.AttributeBasedMergeRuleProvider = (function() {

    function AttributeBasedMergeRuleProvider(typeService) {
      this.typeService = typeService;
      this.Initialize();
    }

    AttributeBasedMergeRuleProvider.prototype.Initialize = function() {
      var collectionType, customAttrubutes, dictionaryType, edge, isOverride, memberId, memberName, propertyInfo, rule, type, typeId, _i, _j, _len, _len1, _ref, _ref1, _results;
      _ref = this.typesService.GetRegisteredTypes();
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        typeId = _ref[_i];
        if (!this.typesService.IsScalarType(typeId)) {
          type = this.typesService.GetTypeFromId(typeId);
          rule = new TypeMergeRule();
          collectionType = null;
          dictionaryType = null;
          customAttrubutes = null;
          if ((!((collectionType = UTILS.IsCollectionType(type)) != null)) && (!((dictionaryType = UTILS.IsDictionaryType(type)) != null))) {
            if ((customAttrubutes = type.GetCustomAttributes("ConcurrentAttribute")).result === true) {
              rule.isConcurrent = true;
              rule.isStaticConcurrency = customAttrubutes.value[0].behavior === ConcurrentBehavior.Static;
              if (!rule.isStaticConcurrency) {
                rule.dynamicResolverType = customAttrubutes.value[0].Resolver;
              } else {
                _ref1 = this.typesService.GetTypeEdges(typeId);
                for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
                  edge = _ref1[_j];
                  if (edge.data.semantic === EdgeType.Property) {
                    memberId = edge.toNodeId;
                    memberName = this.typesService.GetMemberName(typeId, memberId);
                    propertyInfo = type.GetProperty(memberName);
                    if (propertyInfo === null) {
                      throw "Propertie does not exist!";
                    }
                    isOverride = propertyInfo.GetCustomAttributes("OverrideAttribute").result;
                    rule.isMemberOverride.Add(memberId, isOverride);
                  }
                }
              }
            }
          } else {
            rule.isConcurrent = true;
            rule.isStaticConcurrency = true;
          }
          _results.push(typeMergeRules.Add(typeId, rule));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    AttributeBasedMergeRuleProvider.prototype.IsConcurrent = function(typeId) {
      return typeMergeRules[typeId].isConcurrent;
    };

    AttributeBasedMergeRuleProvider.prototype.IsMemberOverride = function(typeId, memberId) {
      return typeMergeRules[typeId].isMemberOverride[memberId];
    };

    AttributeBasedMergeRuleProvider.prototype.IsStaticConcurrency = function(typeId) {
      return typeMergeRules[typeId].isStaticConcurrency;
    };

    return AttributeBasedMergeRuleProvider;

  })();

  window.AutoOverrideMergeRuleProvider = (function() {

    function AutoOverrideMergeRuleProvider() {}

    AutoOverrideMergeRuleProvider.prototype.IsConcurrent = function(typeId) {
      return true;
    };

    AutoOverrideMergeRuleProvider.prototype.IsMemberOverride = function(typeId, memberId) {
      return true;
    };

    AutoOverrideMergeRuleProvider.prototype.IsStaticConcurrency = function(typeId) {
      return true;
    };

    return AutoOverrideMergeRuleProvider;

  })();

  window.TrackingWorkspaceStateProvider = (function() {

    function TrackingWorkspaceStateProvider(workspaceStates) {
      this.workspaceStates = workspaceStates != null ? workspaceStates : new Dictionary();
    }

    TrackingWorkspaceStateProvider.prototype.AddWorkspace = function(workspaceId, snapshotId, isolationLevel, timeout) {
      return this.workspaceStates.Add(workspaceId, new WorkspaceStateElement(snapshotId, isolationLevel, DateTime.utcNow, timeout));
    };

    TrackingWorkspaceStateProvider.prototype.IsWorkspaceExpired = function(workspaceId) {
      return !this.workspaceStates.Contains(workspaceId) || this.workspaceStates[workspaceId].IsExpired();
    };

    TrackingWorkspaceStateProvider.prototype.GetWorkspaceSnapshotId = function(workspaceId) {
      return this.workspaceStates[workspaceId].snapshotId;
    };

    TrackingWorkspaceStateProvider.prototype.RemoveWorkspace = function(workspaceId) {
      var level;
      level = IsolationLevel.ReadOnly;
      level = this.workspaceStates.Get(workspaceId).isolationLevel;
      return this.workspaceStates.Remove(workspaceId);
    };

    TrackingWorkspaceStateProvider.prototype.Cleanup = function() {
      var expiredWorkspaces, item, key, _i, _j, _len, _len1, _ref, _results;
      expiredWorkspaces = [];
      _ref = this.workspaceStates.Keys();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        key = _ref[_i];
        item = this.workspaceStates.Get(key);
        if (item.IsExpired()) {
          expiredWorkspaces.push(key);
        }
      }
      _results = [];
      for (_j = 0, _len1 = expiredWorkspaces.length; _j < _len1; _j++) {
        key = expiredWorkspaces[_j];
        _results.push(this.RemoveWorkspace(key));
      }
      return _results;
    };

    TrackingWorkspaceStateProvider.prototype.UsedSnapshotIds = function() {
      var item, key, res, _i, _len, _ref;
      res = [];
      _ref = this.workspaceStates.Keys();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        key = _ref[_i];
        item = this.workspaceStates.Get(key);
        if (item.IsExpired()) {
          res.push(item.snapshotId);
        }
      }
      return res;
    };

    TrackingWorkspaceStateProvider.prototype.UpdateWorspace = function(workspaceId, snapshotId) {
      this.workspaceStates[workspaceId].lastAccessDateTime = DateTime.utcNow;
      return this.workspaceStates[workspaceId].snapshotId = snapshotId;
    };

    return TrackingWorkspaceStateProvider;

  })();

  WorkspaceStateElement = (function() {

    function WorkspaceStateElement(snapshotId, isolationLevel, lastAccessDateTime, timeout) {
      this.snapshotId = snapshotId;
      this.isolationLevel = isolationLevel;
      this.lastAccessDateTime = lastAccessDateTime;
      this.timeout = timeout;
    }

    WorkspaceStateElement.prototype.IsExpired = function() {
      return (this.lastAccessDateTime.Add(Timeout))._millis < DateTime.utcNow.span._millis;
    };

    return WorkspaceStateElement;

  })();

  AppendableChangeSet = (function() {

    function AppendableChangeSet(sourceSnapshotId, destinationSnapshotId, nodes, mapping, nodeStates, reusedNodes) {
      this.sourceSnapshotId = sourceSnapshotId;
      this.destinationSnapshotId = destinationSnapshotId;
      this.nodes = nodes;
      this.mapping = mapping;
      this.nodeStates = nodeStates;
      this.reusedNodes = reusedNodes;
    }

    return AppendableChangeSet;

  })();

  ParentMapProvider = (function() {

    function ParentMapProvider(nodes, dataNodeProvider, fallbackParentMapProvider, filterMutable) {
      this.nodes = nodes;
      this.dataNodeProvider = dataNodeProvider;
      this.fallbackParentMapProvider = fallbackParentMapProvider;
      this.filterMutable = filterMutable;
      if (this.nodes.equals(this.dataNodeProvider)) {
        throw "Argument exception";
      }
      this.ParentsTreeOrder = 100;
      this.createdNodes = false;
      this.lastSnapshotId = Guid.EMPTY;
    }

    ParentMapProvider.prototype.ParentEdges = function(snapshotId, nodeId) {
      if (!this.createdNodes) {
        this.createdNodes = true;
        this.AddParentsRecursive(snapshotId, new Dictionary(), this.nodes);
        this.lastSnapshotId = snapshotId;
      }
      if (snapshotId !== this.lastSnapshotId) {
        if (this.fallbackParentMapProvider !== null) {
          return this.fallbackParentMapProvider.parentEdges(snapshotId, nodeId);
        } else {
          this.nodes.Clear();
          this.AddParentsRecursive(snapshotId, new Dictionary(), this.nodes);
          this.lastSnapshotId = snapshotId;
        }
      }
      if (nodes.Contains(nodeId)) {
        return BPlusTreeOperations.GetEnumerator(this.nodes, nodeId, EdgeType.Contains);
      } else {
        return null;
      }
    };

    ParentMapProvider.prototype.UpdateParents = function(changeSet, collectedNodesProvider) {
      var edgeData, elem, enumerator, existingEdge, holderNode, key, lastSnapshotId, node, nodeId, rez, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _ref, _ref1, _ref2, _ref3, _ref4;
      if (changeSet.sourceSnapshotId !== this.lastSnapshotId) {
        this.nodes.Clear();
        this.createdNodes = false;
        return;
      }
      enumerator = collectedNodesProvider.GetEdges(changeSet.sourceSnapshotId);
      if ((enumerator != null)) {
        while (enumerator.MoveNext()) {
          if (this.nodes.Contains(enumerator.Current().toNodeId)) {
            this.DeleteTree(enumerator.Current().toNodeId);
          }
          node = this.dataNodeProvider.GetNode(enumerator.Current().toNodeId, NodeAccess.Read);
          _ref = node.edges.values.Keys();
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            key = _ref[_i];
            elem = node.edges.values.Get(key);
            if (this.EdgeFilter(elem)) {
              if (nodes.Contains(edge.ToNodeId)) {
                BPlusTreeOperations.RemoveEdge(this.nodes, edge.toNodeId, new EdgeData(EdgeType.Contains, enumerator.Current().toNodeId), this.ParentsTreeOrder);
              }
            }
          }
        }
      }
      _ref1 = changeSet.nodes.EnumerateNodes();
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        nodeId = _ref1[_j];
        holderNode = BPlusTreeOperations.CreateRootNode(NodeType.Collection, nodeId);
        nodes.SetNode(nodeId, holderNode);
      }
      _ref2 = changeSet.reusedNodes.Keys();
      for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
        nodeId = _ref2[_k];
        if (!nodes.Contains(nodeId)) {
          holderNode = BPlusTreeOperations.CreateRootNode(NodeType.Collection, nodeId);
          this.nodes.SetNode(nodeId, holderNode);
        }
      }
      _ref3 = changeSet.nodes.EnumerateNodes();
      for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
        nodeId = _ref3[_l];
        node = changeSet.nodes.GetNode(nodeId, NodeAccess.Read);
        _ref4 = node.edges.values.Keys();
        for (_m = 0, _len4 = _ref4.length; _m < _len4; _m++) {
          key = _ref4[_m];
          elem = node.edges.values.Get(key);
          if (this.EdgeFilter(elem)) {
            edgeData = new EdgeData(EdgeType.Contains, nodeId);
            existingEdge = null;
            rez = BPlusTreeOperations.TryFindEdge(this.nodes, elem.toNodeId, edgeData);
            if (!rez.result) {
              BPlusTreeOperations.InsertEdge(this.nodes, elem.toNodeId, new Edge(nodeId, edgeData), this.ParentsTreeOrder);
            }
          }
        }
      }
      return lastSnapshotId = changeSet.destinationSnapshotId;
    };

    ParentMapProvider.prototype.EdgeFilter = function(edge) {
      if (this.filterMutable) {
        return !UTILS.IsPermanentEdge(edge);
      } else {
        return ((edge.data.flags === EdgeFlags.Permanent) === EdgeFlags.Permanent) && !(edge.toNodeId === Constants.NullReferenceNodeId) && !(edge.data.semantic === EdgeType.OfType);
      }
    };

    ParentMapProvider.prototype.AddParentsRecursive = function(nodeId, visitedNodes, nodes) {
      var edge, edgeData, existingEdge, holderNode, key, rez, _i, _j, _len, _len1, _ref, _ref1, _results;
      if (nodeId === Constants.NullReferenceNodeId) {
        return;
      }
      if (visitedNodes.Contains(nodeId)) {
        return;
      } else {
        visitedNodes.Add(nodeId, null);
      }
      _ref = this.dataNodeProvider.GetNode(nodeId, NodeAccess.Read).edges.Keys();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        key = _ref[_i];
        edge = this.dataNodeProvider.GetNode(nodeId, NodeAccess.Read).edges.Get(key);
        if (this.EdgeFilter(edge)) {
          if (!nodes.Contains(edge.toNodeId)) {
            holderNode = BPlusTreeOperations.CreateRootNode(NodeType.Collection, edge.toNodeId);
            nodes.SetNode(edge.toNodeId, holderNode);
          }
          edgeData = new EdgeData(EdgeType.Contains, nodeId);
          existingEdge = null;
          rez = BPlusTreeOperations.TryFindEdge(nodes, edge.toNodeId, edgeData);
          if (!rez.result) {
            BPlusTreeOperations.InsertEdge(nodes, edge.toNodeId, new Edge(nodeId, edgeData), this.ParentsTreeOrder);
          }
        }
      }
      _ref1 = this.dataNodeProvider.GetNode(nodeId, NodeAccess.Read).edges.Keys();
      _results = [];
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        key = _ref1[_j];
        edge = this.dataNodeProvider.GetNode(nodeId, NodeAccess.Read).edges.Get(key);
        _results.push(this.AddParentsRecursive(edge.toNodeId, visitedNodes, nodes));
      }
      return _results;
    };

    ParentMapProvider.prototype.DeleteTree = function(nodeId) {
      var edge, key, node, _i, _len, _ref, _results;
      node = this.nodes.GetNode(nodeId, NodeAccess.Read);
      if (node.data.equals(BPlusTreeOperations.InternalNodeData)) {
        _ref = node.edges.Keys();
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          key = _ref[_i];
          edge = node.edges.Get(key);
          _results.push(this.DeleteTree(edge.toNodeId));
        }
        return _results;
      }
    };

    return ParentMapProvider;

  })();

  window.TrackingChangeSetProvider = (function() {

    function TrackingChangeSetProvider(nodes) {
      this.nodes = nodes;
      this.InitializeRoot();
      this.TreeOrder = 100;
    }

    TrackingChangeSetProvider.prototype.InitializeRoot = function() {
      var node;
      if (!nodes.Contains(Constants.SnapshotsNodeId)) {
        node = BPlusTreeOperations.CreateRootNode(NodeType.Collection, Constants.SnapshotsNodeId);
        return nodes.SetNode(Constants.SnapshotsNodeId, node);
      }
    };

    TrackingChangeSetProvider.prototype.SetChangeSet = function(changeSet) {
      var element, key, snapshotNode, _i, _len, _ref;
      snapshotNode = BPlusTreeOperations.CreateRootNode(NodeType.Dictionary, changeSet.DestinationSnapshotId);
      this.nodes.SetNode(changeSet.DestinationSnapshotId, snapshotNode);
      _ref = changeSet.mapping.Keys();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        key = _ref[_i];
        element = changeSet.mapping.Get(key);
        BPlusTreeOperations.InsertEdge(this.nodes, changeSet.DestinationSnapshotId, new Edge(element.Value, new EdgeData(EdgeType.ListItem, key)), TreeOrder);
      }
      return BPlusTreeOperations.InsertEdge(this.nodes, Constants.SnapshotsNodeId, new Edge(changeSet.destinationSnapshotId, new EdgeData(EdgeType.ListItem, changeSet.destinationSnapshotId)), TreeOrder);
    };

    TrackingChangeSetProvider.prototype.GetChangeSetEdges = function(snapshotId) {
      var edge, rez;
      edge = null;
      rez = BPlusTreeOperations.TryFindEdge(this.nodes, Constants.SnapshotsNodeId, new EdgeData(EdgeType.ListItem, snapshotId));
      if (rez.result) {
        return BPlusTreeOperations.GetEnumerator(this.nodes, snapshotId, EdgeType.ListItem);
      } else {
        return new Enumerator();
      }
    };

    TrackingChangeSetProvider.prototype.ContainsSnapshot = function(snapshotId) {
      var edge;
      edge = null;
      return BPlusTreeOperations.TryFindEdge(this.nodes, Constants.SnapshotsNodeId, new EdgeData(EdgeType.ListItem, snapshotId)).result;
    };

    TrackingChangeSetProvider.prototype.RemoveChangeSet = function(snapshotId) {
      if (BPlusTreeOperations.RemoveEdge(this.nodes, Constants.SnapshotsNodeId, new EdgeData(EdgeType.ListItem, snapshotId), TreeOrder)) {
        return this.DeleteTree(snapshotId);
      }
    };

    TrackingChangeSetProvider.prototype.DeleteTree = function(nodeId) {
      var elem, key, node, _i, _len, _ref;
      node = this.nodes.GetNode(nodeId, NodeAccess.Read);
      if (node.data.equals(BPlusTreeOperations.InternalNodeData)) {
        _ref = node.edges.Keys();
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          key = _ref[_i];
          elem = node.edges.Get(key);
          this.DeleteTree(elem.toNodeId);
        }
      }
      return this.nodes.Remove(nodeId);
    };

    return TrackingChangeSetProvider;

  })();

  window.SnapshotsService = (function() {

    function SnapshotsService(provider) {
      this.provider = provider != null ? provider : new DirectNodeProvider();
    }

    SnapshotsService.prototype.GetRootObjectId = function() {
      return this.provider.GetNode(snapshotId, NodeAccess.Read).FindEdge(new EdgeData(EdgeType.RootObject, null)).toNodeId;
    };

    SnapshotsService.prototype.GetLatestSnapshotId = function() {
      var edge, node;
      node = this.provider.GetNode(Constants.SnapshotsNodeId, NodeAccess.Read);
      edge = node.FindEdge(new EdgeData(EdgeType.Contains, null));
      return edge.toNodeId;
    };

    SnapshotsService.prototype.InitializeSnapshots = function() {
      var snapshotsNode;
      if (!this.provider.Contains(Constants.SnapshotsNodeId)) {
        snapshotsNode = new Node(NodeType.SnapshotsRoot, null);
        this.provider.SetNode(Constants.SnapshotsNodeId, snapshotsNode);
        return true;
      }
      return false;
    };

    SnapshotsService.prototype.AddSnapshot = function(snapshotId) {
      var node;
      node = new Node(NodeType.SnapshotsRoot, null);
      node.AddEdge(new Edge(snapshotId, new EdgeData(EdgeType.Contains, null)));
      return this.provider.SetNode(Constants.SnapshotsNodeId, node);
    };

    SnapshotsService.prototype.SnapshotsBetweenReverse = function(source, destination) {
      var current, node, res;
      res = [];
      current = destination;
      while (!current.equals(source)) {
        res.push(current);
        node = this.provider.GetNode(current, NodeAccess.Read);
        current = node.previous;
        if (current.equals(Guid.EMPTY)) {
          throw "Destination snapshot is expected to be after the source snapshot";
        }
      }
      res.push(current);
      return res;
    };

    SnapshotsService.prototype.ListSnapshots = function() {
      var current, node, res;
      res = [];
      current = this.GetLatestSnapshotId();
      while (!current.equals(Guid.EMPTY)) {
        res.push(current);
        node = this.provider.GetNode(current, NodeAccess.Read);
        current = node.previous;
      }
      return res;
    };

    SnapshotsService.prototype.RemoveUnusedSnapshots = function(usedSnapshots) {
      var current, lastUsedNode, lastUsedNodeId, node, result;
      result = [];
      current = this.GetLatestSnapshotId();
      lastUsedNodeId = Guid.EMPTY;
      while (!current.equals(Guid.EMPTY)) {
        if (usedSnapshots.indexOf(current) !== -1) {
          result = [];
          lastUsedNodeId = current;
        } else {
          result.push(current);
        }
        node = this.provider.GetNode(current, NodeAccess.Read);
        current = node.previous;
      }
      lastUsedNode = this.provider.GetNode(lastUsedNodeId, NodeAccess.ReadWrite);
      lastUsedNode.previous = Guid.EMPTY;
      this.provider.SetNode(lastUsedNodeId, lastUsedNode);
      return result;
    };

    SnapshotsService.prototype.ResetSnapshots = function() {
      var lastUsedNode, lastUsedNodeId;
      lastUsedNodeId = this.GetLatestSnapshotId();
      lastUsedNode = this.provider.GetNode(lastUsedNodeId, NodeAccess.ReadWrite);
      lastUsedNode.previous = Guid.EMPTY;
      this.provider.SetNode(lastUsedNodeId, lastUsedNode);
    };

    return SnapshotsService;

  })();

  window.IsolatedChangeSet = (function() {

    function IsolatedChangeSet(sourceSnapshotId, nodes, nodeStates) {
      this.sourceSnapshotId = sourceSnapshotId;
      this.nodes = nodes != null ? nodes : new DirectNodeProvider();
      this.nodeStates = nodeStates != null ? nodeStates : new Dictionary();
    }

    return IsolatedChangeSet;

  })();

  IsolatedNodeProvider = (function() {

    function IsolatedNodeProvider(parentProvider, isolatedProvider) {
      this.parentProvider = parentProvider;
      this.isolatedProvider = isolatedProvider;
      this.nodeStates = new Dictionary();
    }

    IsolatedNodeProvider.prototype.SetNode = function(identifier, node) {
      this.isolatedProvider.SetNode(identifier, node);
      if (!this.nodeStates.Contains(identifier)) {
        return this.nodeStates.Add(identifier, NodeState.Created);
      }
    };

    IsolatedNodeProvider.prototype.GetNode = function(nodeId, access) {
      if (access === NodeAccess.ReadWrite) {
        this.EnsureNode(nodeId);
        return this.isolatedProvider.GetNode(nodeId, access);
      } else {
        if (this.isolatedProvider.Contains(nodeId)) {
          return this.isolatedProvider.GetNode(nodeId, access);
        } else {
          return this.parentProvider.GetNode(nodeId, access);
        }
      }
    };

    IsolatedNodeProvider.prototype.Contains = function(identifier) {
      return this.isolatedProvider.Contains(identifier) || this.parentProvider.Contains(identifier);
    };

    IsolatedNodeProvider.prototype.Remove = function(identifier) {
      this.EnsureNode(identifier);
      return this.nodeStates.Set(identifier, NodeState.Removed);
    };

    IsolatedNodeProvider.prototype.EnumerateNodes = function() {
      return this.parentProvider.EnumerateNodes();
    };

    IsolatedNodeProvider.prototype.GetChanges = function(snapshotId) {
      return new IsolatedChangeSet(snapshotId, this.isolatedProvider, this.nodeStates);
    };

    IsolatedNodeProvider.prototype.EnumerateChanges = function() {
      return this.isolatedProvider.EnumerateNodes();
    };

    IsolatedNodeProvider.prototype.GetNodeState = function() {
      if (this.nodeStates.Contains(identifier)) {
        return this.nodeStates.Get(identifier);
      } else {
        return NodeState.None;
      }
    };

    IsolatedNodeProvider.prototype.Clear = function() {
      this.isolatedProvider.Clear();
      return this.nodeStates.Clear();
    };

    IsolatedNodeProvider.prototype.EnsureNode = function(nodeId) {
      var edge, edgeList, key, newNode, node, value, valueList, _i, _j, _len, _len1, _ref, _ref1;
      if (!this.isolatedProvider.Contains(nodeId)) {
        node = this.parentProvider.GetNode(nodeId, NodeAccess.Read);
        edgeList = new Dictionary();
        _ref = node.edges.Keys();
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          key = _ref[_i];
          edge = node.edges.Get(key);
          edgeList.Add(edge.data, new Edge(edge.toNodeId, new EdgeData(edge.data.semantic, edge.data.data, edge.data.flags)));
        }
        valueList = new Dictionary();
        _ref1 = node.values.Keys();
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          key = _ref1[_j];
          value = node.values.Get(key);
          valueList.Add(key, value);
        }
        newNode = new Node(node.nodeType, node.data, edgeList, valueList);
        newNode.commited = false;
        this.isolatedProvider.SetNode(nodeId, newNode);
        return this.nodeStates.Add(nodeId, NodeState.Modified);
      }
    };

    return IsolatedNodeProvider;

  })();

  RecursiveResolutionParameters = (function() {

    function RecursiveResolutionParameters(subTree, destinationProvider, sourceProvider, changeSet, intermediateChanges, visitedNodes) {
      this.subTree = subTree;
      this.destinationProvider = destinationProvider;
      this.sourceProvider = sourceProvider;
      this.changeSet = changeSet;
      this.intermediateChanges = intermediateChanges;
      this.visitedNodes = visitedNodes;
    }

    return RecursiveResolutionParameters;

  })();

  window.CommitResult = (function() {

    function CommitResult(resultSnapshotId, mapping) {
      this.resultSnapshotId = resultSnapshotId;
      this.mapping = mapping;
    }

    return CommitResult;

  })();

  CommitDataService = (function() {

    function CommitDataService(nodes, typesService, snapshotsService, mutableParentProvider, immutableParentProvider, changeSetProvider, nodeMergeExecutor, collectedNodesProvider) {
      this.nodes = nodes;
      this.typesService = typesService;
      this.snapshotsService = snapshotsService;
      this.mutableParentProvider = mutableParentProvider;
      this.immutableParentProvider = immutableParentProvider;
      this.changeSetProvider = changeSetProvider;
      this.nodeMergeExecutor = nodeMergeExecutor;
      this.collectedNodesProvider = collectedNodesProvider;
    }

    CommitDataService.prototype.AcceptCommit = function(isolatedChangeSet) {
      var appendableChangeSet, boolSnapIdEqualLatestSnap, intermediateChanges, item, key, latestSnapshot, mapping, mergedChangeSet, subTree, _i, _len, _ref;
      latestSnapshot = this.snapshotsService.GetLatestSnapshotId();
      boolSnapIdEqualLatestSnap = latestSnapshot.equals(isolatedChangeSet.sourceSnapshotId);
      if (boolSnapIdEqualLatestSnap) {
        appendableChangeSet = CreateAppendableChangeSet(isolatedChangeSet.sourceSnapshotId, Guid.Create(), isolatedChangeSet);
        this.CommitDirect(appendableChangeSet);
        return new CommitResult(appendableChangeSet.destinationSnapshotId, appendableChangeSet.mapping);
      } else {
        intermediateChanges = this.ChangesBetween(isolatedChangeSet.sourceSnapshotId, latestSnapshot);
        subTree = this.IsolateSubTree(latestSnapshot, isolatedChangeSet, intermediateChanges);
        mergedChangeSet = this.CreateMergedChangeSet(latestSnapshot, subTree, isolatedChangeSet, intermediateChanges);
        this.CommitDirect(mergedChangeSet);
        mapping = mergedChangeSet.mapping;
        _ref = intermediateChanges.Keys();
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          key = _ref[_i];
          item = intermediateChanges.Get(key);
          this.AddChangeItem(mapping, key, item);
        }
        return new CommitResult(mergedChangeSet.destinationSnapshotId, mapping);
      }
    };

    CommitDataService.prototype.CreateMergedChangeSet = function(latestSnapshot, subTree, changeSet, intermediateChanges) {};

    CommitDataService.prototype.FindTreeAddedElements = function(nodeId, parameters) {
      var addedElements, edge, enumerator, foundEdge, item, key, originalNodeId, removedElements, rez, _i, _len, _ref, _results;
      addedElements = new Dictionary();
      removedElements = new Dictionary();
      originalNodeId = Guid.EMPTY;
      _ref = parameters.intermediateChanges.Keys();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        key = _ref[_i];
        item = parameters.intermediateChanges.Get(key);
        if (item.equals(nodeId)) {
          originalNodeId = key;
          break;
        }
      }
      if (originalNodeId.equals(Guid.EMPTY)) {
        originalNodeId = nodeId;
      }
      enumerator = BPlusTreeOperations.GetEnumerator(parameters.sourceProvider, originalNodeId, EdgeType.ListItem);
      while (enumerator.MoveNext()) {
        edge = enumerator.Current();
        foundEdge = null;
        rez = BPlusTreeOperations.TryFindEdge(this.nodes, nodeId, edge.data);
        if (!rez.result) {
          addedElements.Add(edge.data, edge);
        }
      }
      enumerator = BPlusTreeOperations.GetEnumerator(this.nodes, originalNodeId, EdgeType.ListItem);
      _results = [];
      while (enumerator.MoveNext()) {
        edge = enumerator.Current();
        foundEdge = null;
        rez = BPlusTreeOperations.TryFindEdge(parameters.sourceProvider, originalNodeId, edge.data);
        if (!rez.result) {
          _results.push(removedElements.Add(edge.data, edge));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    CommitDataService.prototype.InsertRecursive = function(nodeId, parameters) {
      var item, key, newReferenceId, node, referenceState, _i, _len, _ref;
      if (parameters.visitedNodes.Contains(nodeId)) {
        return;
      }
      parameters.visitedNodes.Add(nodeId, null);
      node = null;
      if (parameters.changeSet.nodes.Contains(nodeId)) {
        node = parameters.changeSet.nodes.GetNode(nodeId, NodeAccess.Read);
      } else {
        node = nodes.GetNode(nodeId, NodeAccess.Read);
      }
      _ref = node.edges.Keys();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        key = _ref[_i];
        item = node.edges.Get(key);
        newReferenceId = Guid.EMPTY;
        newReferenceId = parameters.intermediateChanges.Get(item.toNodeId);
        if (!UTILS.IsPermanentEdge(item.Value) && (newReferenceId != null)) {
          node.edges.Get(key).toNodeId = newReferenceId;
        }
        referenceState = NodeState.None;
        referenceState = parameters.changeSet.nodeStates.Get(item.toNodeId);
        if ((referenceState != null)) {
          if (referenceState === NodeState.Created) {
            this.InsertRecursive(item.toNodeId, parameters);
          }
        }
      }
      return parameters.destinationProvider.SetNode(nodeId, node);
    };

    CommitDataService.prototype.IsolateSubTree = function(snapshotId, changeSet, intermediateChanges) {
      var changes, item, key, nodeId, oldNodeId, result, _i, _j, _len, _len1, _ref;
      result = new Dictionary();
      changes = [];
      _ref = changeSet.Nodes.EnumerateNodes();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        key = _ref[_i];
        if (changeSet.nodeStates.Get(item) === NodeState.Modified) {
          nodeId = Guid.EMPTY;
          oldNodeId = Guid.EMPTY;
          if (((nodeId = intermediateChanges.Get(item)) != null)) {
            oldNodeId = item;
          } else {
            nodeId = item;
          }
          result.Add(nodeId, oldNOdeId);
          changes.Add(nodeId);
        }
      }
      for (_j = 0, _len1 = changes.length; _j < _len1; _j++) {
        item = changes[_j];
        this.AddSubTreeParentsRecursive(snapshotId, item, result);
      }
      return result;
    };

    CommitDataService.prototype.AddSubTreeParentsRecursive = function(snapshotId, nodeId, table) {
      var parents, _results;
      parents = this.mutableParentProvider.ParentEdges(snapshotId, nodeId);
      if (parents === null) {
        throw "Changed object is no longer reachable in the last snapshot";
      } else {
        _results = [];
        while (parents.MoveNext()) {
          if (!table.Contains(parents.Current().toNodeId)) {
            table.Add(parents.Current().toNodeId, Guid.EMPTY);
            _results.push(this.AddSubTreeParentsRecursive(snapshotId, parents.Current().toNodeId, table));
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      }
    };

    CommitDataService.prototype.ChangesBetween = function(source, destination) {
      var change, changes, snapshotId, snapshots, _i, _len;
      snapshots = this.snapshotsService.SnapshotsBetweenReverse(source, destination);
      changes = new Dictionary();
      for (_i = 0, _len = snapshots.length; _i < _len; _i++) {
        snapshotId = snapshots[_i];
        if (snapshotId !== source) {
          if (changeSetProvider.ContainsSnapshot(snapshotId)) {
            change = changeSetProvider.GetChangeSetEdges(snapshotId);
            this.AppendChange(change, changes);
          } else {
            throw "There is no commit history for given snapshot";
          }
        }
      }
      return changes;
    };

    CommitDataService.prototype.AppendChange = function(change, changes) {
      var key, value, _results;
      _results = [];
      while (change.MoveNext()) {
        key = change.Current().data.data;
        value = change.Current().toNodeId;
        _results.push(this.AppendChangeItem(changes, key, value));
      }
      return _results;
    };

    CommitDataService.AppendChangeItem = function(mapping, source, destination) {
      var existingValue;
      if (mapping.Contains(destination)) {
        existingValue = mapping.Get(destination);
        mapping.Remove(destination);
        return mapping.Add(source, existingValue);
      } else {
        if (!mapping.Contains(source)) {
          return mapping.Add(source, destination);
        } else {
          throw "Key already in map";
        }
      }
    };

    CommitDataService.AddChangeItem = function(mapping, source, destination) {
      var existingValue;
      if (mapping.Contains(destination)) {
        existingValue = mapping.Get(destination);
        return mapping.Add(source, existingValue);
      } else {
        if (!mapping.Contains(source)) {
          return mapping.Add(source, destination);
        } else {
          throw "Key already in map";
        }
      }
    };

    CommitDataService.prototype.CreateAppendableChangeSet = function(baseSnapshotId, newSnapshotId, changeSet) {
      var nodeMapping, nodeStates, reusedNodes, tree;
      nodeMapping = new Dictionary();
      nodeStates = new Dictionary();
      reusedNodes = new Dictionary();
      tree = this.CreateAppendableChangeSetTree(baseSnapshotId, newSnapshotId, new MemoryStorage(), nodeMapping, nodeStates, changeSet, reusedNodes);
      return new AppendableChangeSet(baseSnapshotId, newSnapshotId, tree, nodeMapping, nodeStates, reusedNodes);
    };

    CommitDataService.prototype.CreateAppendableChangeSetTree = function(baseSnapshotId, newSnapshotId, storage, nodeMapping, nodeStates, changeSet, reusedNodes) {
      var delta, edge, key, mappingKey, node, nodeId, otherKey, references, removed, snapshotNode, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _len6, _m, _n, _o, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;
      delta = new DirectNodeProvider(storage, storage === IForceUpdateStorage);
      nodeMapping.Add(baseSnapshotId, newSnapshotId);
      snapshotNode = new Node(NodeType.Snapshot, null);
      snapshotNode.previous = baseSnapshotId;
      snapshotNode.AddEdge(new Edge(snapshotsService.GetRootObjectId(baseSnapshotId), new EdgeData(EdgeType.RootObject, null)));
      delta.SetNode(newSnapshotId, snapshotNode);
      _ref = changeSet.nodes.EnumerateNodes();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        nodeId = _ref[_i];
        this.AddNodeToAppendableTreeRecursive(delta, nodeId, nodeMapping, nodeStates, changeSet);
      }
      references = new Dictionary();
      _ref1 = delta.EnumerateNodes();
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        nodeId = _ref1[_j];
        references.Add(nodeId, []);
      }
      _ref2 = delta.EnumerateNodes();
      for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
        nodeId = _ref2[_k];
        node = delta.GetNode(nodeId, NodeAccess.ReadWrite);
        _ref3 = node.edges.values.Keys();
        for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
          key = _ref3[_l];
          edge = node.edges.values.Get(key);
          if (!UTILS.IsPermanentEdge(edge)) {
            if (nodeMapping.Contains(edge.toNodeId)) {
              edge.toNodeId = nodeMapping.Get(edge.toNodeId);
            } else {
              if (!reusedNodes.Contains(edge.toNodeId)) {
                reusedNodes.Add(edge.toNodeId, null);
              }
            }
            if ((edge.data.data != null) && !Guid.tryParse(edge.data.data).equals(Guid.EMPTY)) {
              if (nodeMapping.Contains(edge.data.data)) {
                edge.data = new EdgeData(edge.data.semantic, nodeMapping.Get(edge.data.data));
              }
            }
          } else {
            if (!reusedNodes.Contains(edge.toNodeId)) {
              reusedNodes.Add(edge.toNodeId, null);
            }
          }
          if (references.Contains(edge.toNodeId)) {
            references.Get(edge.toNodeId).Add(nodeId);
          }
        }
      }
      removed = false;
      while (removed) {
        removed = false;
        _ref4 = delta.EnumerateNodes();
        for (_m = 0, _len4 = _ref4.length; _m < _len4; _m++) {
          key = _ref4[_m];
          if ((key !== newSnapshotId) && (references.Get(key).Count() === 0)) {
            delta.Remove(key);
            _ref5 = references.Keys();
            for (_n = 0, _len5 = _ref5.length; _n < _len5; _n++) {
              otherKey = _ref5[_n];
              references.Get(otherKey).Remove(key);
            }
            _ref6 = nodeMapping.Keys();
            for (_o = 0, _len6 = _ref6.length; _o < _len6; _o++) {
              mappingKey = _ref6[_o];
              if (nodeMapping.Get(mappingKey) === key) {
                nodeMapping.Remove(mappingKey);
                break;
              }
            }
            removed = true;
            break;
          }
        }
      }
      changeSet.nodes.Clear();
      changeSet.nodeStates.Clear();
      return delta;
    };

    CommitDataService.prototype.AddNodeToAppendableTreeRecursive = function(delta, nodeId, nodeMapping, nodeStates, changeSet) {
      var enumerator, newId, newNode, node, nodeState, _results, _results1;
      if (!nodeMapping.Contains(nodeId)) {
        newId = Guid.Create();
        nodeState = NodeState.None;
        nodeState = changeSet.NodeStates.Get(nodeId);
        switch (nodeState) {
          case NodeState.None:
            nodeMapping.Add(nodeId, newId);
            node = this.nodes.GetNode(nodeId, NodeAccess.Read);
            newNode = this.CloneNode(node);
            newNode.commited = true;
            newNode.previous = nodeId;
            delta.SetNode(newId, newNode);
            nodeStates.Add(newId, NodeState.Modified);
            enumerator = mutableParentProvider.ParentEdges(changeSet.sourceSnapshotId, nodeId);
            if (enumerator !== null) {
              _results = [];
              while (enumerator.MoveNext()) {
                _results.push(this.AddNodeToAppendableTreeRecursive(delta, enumerator.Current().toNodeId, nodeMapping, nodeStates, changeSet));
              }
              return _results;
            }
            break;
          case NodeState.Created:
            node = changeSet.nodes.GetNode(nodeId, NodeAccess.ReadWrite);
            node.commited = true;
            node.previous = Guid.EMPTY;
            delta.SetNode(nodeId, node);
            return nodeStates.Add(nodeId, NodeState.Created);
          case NodeState.Modified:
            nodeMapping.Add(nodeId, newId);
            node = changeSet.nodes.GetNode(nodeId, NodeAccess.ReadWrite);
            node.commited = true;
            node.previous = nodeId;
            delta.SetNode(newId, node);
            nodeStates.Add(newId, NodeState.Modified);
            enumerator = mutableParentProvider.ParentEdges(changeSet.sourceSnapshotId, nodeId);
            _results1 = [];
            while (enumerator.MoveNext()) {
              _results1.push(this.AddNodeToAppendableTreeRecursive(delta, enumerator.Current().toNodeId, nodeMapping, nodeStates, changeSet));
            }
            return _results1;
            break;
          case NodeState.Removed:
            throw "This is not implemented!";
            break;
          default:
            throw "NodeState is " + nodeState;
        }
      }
    };

    CommitDataService.prototype.CloneNode = function(node) {
      var edge, edgeList, key, newNode, valueItem, valueList, _i, _j, _len, _len1, _ref, _ref1;
      edgeList = new Dictionary();
      _ref = node.edges.values.Keys();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        key = _ref[_i];
        edge = node.edges.values.Get(key);
        edgeList.Add(edge.data, new Edge(edge.toNodeId, new EdgeData(edge.data.semantic, edge.data.flags, edge.data.data)));
      }
      valueList = new Dictionary();
      _ref1 = node.values.Keys();
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        key = _ref1[_j];
        valueItem = node.values.Get(key);
        valueList.Add(valueItem.key, valueItem.value);
      }
      newNode = new Node(node.nodeType, node.data, edgeList, valueList);
      return newNode;
    };

    CommitDataService.prototype.CommitDirect = function(changeSet) {
      var node, nodeId, _i, _len, _ref;
      _ref = changeSet.nodes.EnumerateNodes();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        nodeId = _ref[_i];
        node = changeSet.nodes.GetNode(nodeId, NodeAccess.Read);
        this.nodes.SetNode(nodeId, node);
      }
      this.changeSetProvider.SetChangeSet(changeSet);
      this.collectedNodesProvider.StoreChangeset(changeSet, this.mutableParentProvider, this.immutableParentProvider);
      this.mutableParentProvider.UpdateParents(changeSet, this.collectedNodesProvider);
      this.immutableParentProvider.UpdateParents(changeSet, this.collectedNodesProvider);
      return this.snapshotsService.AddSnapshot(changeSet.destinationSnapshotId);
    };

    return CommitDataService;

  })();

  window.NodeMergeExecutor = (function() {

    function NodeMergeExecutor(objectAttributeProvider, typesService) {
      this.objectAttributeProvider = objectAttributeProvider;
      this.typesService = typesService;
    }

    NodeMergeExecutor.prototype.MergeObjects = function(nodeId, originalNode, changedNode, node, mergeRecursive, insertRecursive, parameters) {
      var instanceType, typeId;
      typeId = this.typesService.GetInstanceTypeId(originalNode);
      if (!this.objectAttributeProvider.IsConcurrent(typeId)) {
        instanceType = this.typesService.GetTypeFromId(this.typesService.GetInstanceTypeId(nodeId));
        throw "Concurrent modification not allowed for entity type:" + instanceType.name;
      }
      if (this.objectAttributeProvider.IsStaticConcurrency(typeId)) {
        return this.MergeObjectsStatic(nodeId, typeId, originalNode, changedNode, node, mergeRecursive, insertRecursive, parameters);
      } else {
        throw "Dynamic concurrency not implemented";
      }
    };

    NodeMergeExecutor.prototype.ChangeObject = function(nodeId, changedNode, node, mergeRecursive, insertRecursive, parameters) {
      var edge, key, newReference, nodeState, _i, _j, _len, _len1, _ref, _ref1, _results;
      _ref = changedNode.values.Keys();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        key = _ref[_i];
        node.Add(key, changedNode.Get(key));
      }
      _ref1 = changedNode.edges.Array();
      _results = [];
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        edge = _ref1[_j];
        newReference = edge.toNodeId;
        nodeState = NodeState.None;
        nodeState = parameters.changeSet.nodeStates.Get(newReference);
        if (nodeState === null) {
          nodeState = NodeState.None;
        }
        if (nodeState === NodeState.Created) {
          node.SetEdgeToNode(edge.data, newReference);
          _results.push(insertRecursive(newReference, parameters)());
        } else {
          node.SetEdgeToNode(edge.data, newReference);
          _results.push(mergeRecursive(newReference, parameters)());
        }
      }
      return _results;
    };

    NodeMergeExecutor.prototype.MergeObjectsStatic = function(nodeId, typeId, originalNode, changedNode, node, mergeRecursive, insertRecursive, parameters) {
      var edge, element, isOverride, key, newReference, newReferenceUpdated, nodeState, _i, _j, _len, _len1, _ref, _ref1, _results;
      _ref = originalNode.values.Keys();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        key = _ref[_i];
        element = originalNode.values.Get(key);
        if (!changedNode.values.Get(key).equals(element)) {
          if (node.values.Get(key).equals(element)) {
            node.values.Set(key, changedNode.values.Get(key));
          } else {
            if (this.objectAttributeProvider.IsMemberOverride(typeId, key)) {
              node.values.Set(key, changedNode.values.Get(key));
            } else {
              throw "Concurrent modification of scalar value not allowed in type:" + typesService.GetTypeFromId(typeId).name;
            }
          }
        }
      }
      _ref1 = originalNode.edges;
      _results = [];
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        edge = _ref1[_j];
        isOverride = false;
        if (!changedNode.edges.Get(edge.key).toNodeId === edge.value.toNodeId) {
          isOverride = this.objectAttributeProvider.IsMemberOverride(typeId, edge.key.data);
          if (node.edges.Get(edge.key).toNodeId === edge.value.toNodeId || isOverride) {
            newReference = changedNode.edges.Get(edge.key).toNodeId;
            newReferenceUpdated = Guid.EMPTY;
            if (((newReferenceUpdated = parameters.intermediateChanges.Get(newReference)) != null)) {
              node.SetEdgeToNode(edge.value.data, newReferenceUpdated);
              _results.push(mergeRecursive(newReferenceUpdated, parameters));
            } else {
              nodeState = NodeState.None;
              nodeState = parameters.changeSet.nodeStates.Get(newReference);
              if (nodeState === NodeState.Created) {
                node.SetEdgeToNode(edge.value.data, newReference);
                _results.push(insertRecursive(newReference, parameters));
              } else {
                node.SetEdgeToNode(edge.value.data, newReference);
                _results.push(mergeRecursive(newReference, parameters));
              }
            }
          } else {
            throw "Concurrent modification of referenced item not allowed in type:" + typesService.GetTypeFromId(typeId).name;
          }
        } else {
          _results.push(mergeRecursive(node.edges.Get(edge.key).toNodeId, parameters));
        }
      }
      return _results;
    };

    return NodeMergeExecutor;

  })();

  window.WorkspaceFacade = (function() {

    function WorkspaceFacade(commitDataService, workspaceStateProvider, subscriptionManagerService, snapshotsService) {
      this.commitDataService = commitDataService;
      this.workspaceStateProvider = workspaceStateProvider;
      this.subscriptionManagerService = subscriptionManagerService != null ? subscriptionManagerService : null;
      this.snapshotsService = snapshotsService;
    }

    WorkspaceFacade.prototype.Commit = function(workspaceId, changeSet, type) {
      var result;
      if (!this.workspaceStateProvider.IsWorkspaceExpired(workspaceId)) {
        result = this.commitDataService.AcceptCommit(changeSet);
        this.workspaceStateProvider.UpdateWorspace(workspaceId, result.ResultSnapshotId);
        return result;
      } else {
        throw "Workspace timeout has elapsed";
      }
    };

    WorkspaceFacade.prototype.OpenWorkspace = function(workspaceId, snapshotId, isolationLevel, timeout) {
      this.workspaceStateProvider.AddWorkspace(workspaceId, snapshotId, isolationLevel, timeout);
    };

    WorkspaceFacade.prototype.UpdateWorkspace = function(workspaceId, snapshotId) {
      this.workspaceStateProvider.UpdateWorspace(workspaceId, snapshotId);
    };

    WorkspaceFacade.prototype.CloseWorkspace = function(workspaceId) {
      this.workspaceStateProvider.RemoveWorkspace(workspaceId);
    };

    WorkspaceFacade.prototype.ChangesBetween = function(oldSnapshotId, newSnapshotId) {
      return this.commitDataService.ChangesBetween(oldSnapshotId, newSnapshotId);
    };

    WorkspaceFacade.prototype.CreateSubscription = function(workspaceId, instanceId, notifyChangesFromSameWorkspace, del, propertyName) {
      throw "Not implemented!";
    };

    WorkspaceFacade.prototype.RemoveSubscription = function(subscription) {
      throw "Not implemented!";
    };

    WorkspaceFacade.prototype.GetRootObjectId = function(snapshotId) {
      return this.snapshotsService.GetRootObjectId(snapshotId);
    };

    WorkspaceFacade.prototype.LastSnapshotId = function() {
      return this.snapshotsService.GetLatestSnapshotId();
    };

    return WorkspaceFacade;

  })();

  window.ServerContext = (function() {

    ServerContext.TYPE = "Type";

    ServerContext.IOG_TYPE = "iogType";

    ServerContext.NODE = 'node';

    ServerContext.IDENTIFIER = 'identifier';

    ServerContext.RESULT = "result";

    ServerContext.R20 = /%20/g;

    ServerContext.COMMITED = "Commited";

    ServerContext.NODE_TYPE = "NodeType";

    ServerContext.VALUES = "Values";

    ServerContext.EDGES = "Edges";

    ServerContext.DATA = "Data";

    ServerContext.PREVIOUS = "Previous";

    ServerContext.KEY = "Key";

    ServerContext.VALUE = "Value";

    ServerContext.SEMANTIC = "Semantic";

    ServerContext.FLAGS = "Flags";

    ServerContext.TYPE_NAME = "TypeName";

    ServerContext.TO_NODE_ID = "ToNodeId";

    ServerContext.NODE_ID = "nodeId";

    ServerContext.ACCESS = "access";

    ServerContext.WORKSPACE_ID = "workspaceId";

    ServerContext.SNAPSHOT_ID = "snapshotId";

    ServerContext.ISOLATION_LEVEL = "isolationLevel";

    ServerContext.TIMEOUT = "timeout";

    ServerContext.SNAPSHOT_ID = "snapshotId";

    ServerContext.OLD_SNAPSHOT_ID = "oldSnapshotId";

    ServerContext.NEW_SNAPSHOT_ID = "newSnapshotId";

    ServerContext.WORKSPACE_ID = "workspaceId";

    ServerContext.SNAPSHOT_ID = "snapshotId";

    ServerContext.CHANGE_SET = "changeSet";

    ServerContext.RESULT_SNAPSHOT_ID = "ResultSnapshotId";

    ServerContext.MAPPING = "Mapping";

    ServerContext.NAME_OF_TYPE = "NameOfType";

    ServerContext.GENERIC_ARGUMENTS_TYPE_NAME = "GenericAgrumentsTypeName";

    function ServerContext(hostname, serviceName) {
      this.hostname = hostname;
      this.serviceName = serviceName;
    }

    ServerContext.ProcessDataForSending = function(data) {
      return JSON.stringify(data);
    };

    ServerContext.prototype.ServiceCall = function(functionName, dataForSending, handler) {
      return $.ajax({
        type: "POST",
        contentType: "application/json; charset=utf-8",
        url: ("" + this.serviceName + "/") + functionName,
        data: dataForSending != null ? ServerContext.ProcessDataForSending(dataForSending) : "",
        async: false,
        dataType: "json",
        success: function(msg) {
          return handler(msg);
        },
        error: function(e) {
          return alert('Error, this is not working!' + e.getAllResponseHeaders());
        }
      });
    };

    ServerContext.prototype.LastSnapshotId = function() {
      var rez;
      rez = null;
      this.ServiceCall("LastSnapshotId", null, function(msg) {
        var resultJson, temp;
        temp = msg.d;
        resultJson = JSON.parse(temp);
        return rez = new Guid(resultJson[ServerContext.RESULT]);
      });
      return rez;
    };

    ServerContext.prototype.EnterExclusiveLock = function() {
      return this.ServiceCall("EnterExclusiveLock", null, function(msg) {});
    };

    ServerContext.prototype.EnterSharedLock = function() {
      return this.ServiceCall("EnterSharedLock", null, function(msg) {});
    };

    ServerContext.prototype.SnapshotIsolationEnabled = function() {
      var tempSnapshotIsolationEnabled;
      tempSnapshotIsolationEnabled = null;
      this.ServiceCall("SnapshotIsolationEnabled", null, function(msg) {
        var temp;
        temp = msg.d;
        return tempSnapshotIsolationEnabled = JSON.parse(temp)[ServerContext.RESULT];
      });
      return tempSnapshotIsolationEnabled;
    };

    ServerContext.prototype.DefaultWorkspaceTimeout = function() {
      var tempDefaultWorkspaceTimeout;
      tempDefaultWorkspaceTimeout = null;
      this.ServiceCall("DefaultWorkspaceTimeout", null, function(msg) {
        var temp, tempSpan;
        temp = msg.d;
        tempSpan = new TimeSpan();
        tempSpan._millis = JSON.parse(temp)[ServerContext.RESULT];
        tempSpan[ServerContext.IOG_TYPE] = TimeSpanType;
        return tempDefaultWorkspaceTimeout = tempSpan;
      });
      return tempDefaultWorkspaceTimeout;
    };

    ServerContext.prototype.EntityTypes = function() {
      return this.ServiceCall("EntityTypes", null, function(msg) {
        var elem, genericType, newType, temp, _i, _len;
        temp = msg.d;
        temp = JSON.parse(temp);
        for (_i = 0, _len = temp.length; _i < _len; _i++) {
          elem = temp[_i];
          newType = ServerContext.ExtractType(elem);
          window.types.push(newType);
          genericType = newType;
          genericType.ClearGenericArguments();
          window[newType.name + ServerContext.TYPE] = genericType;
          if (newType.isCollectionType) {
            window.ArrayType = genericType;
          }
          if (newType.isDictionaryType) {
            window.DictionaryType = genericType;
          }
          IOGType.FindScalar(newType);
        }
        BPlusTreeOperations.InitFields();
        EdgeDataSingleton.MAX_VALUE.data = new Guid("53F11357-62B7-430F-B446-9EC8F9702406");
        return EdgeDataSingleton.MIN_VALUE.data = new Guid("76367091-B69D-4BDF-A643-779032AF3503");
      });
    };

    ServerContext.prototype.OpenWorkspace = function(workspaceId, snapshotId, isolationLevel, timeout) {
      var objectForSending;
      objectForSending = {};
      objectForSending[ServerContext.WORKSPACE_ID] = workspaceId.value;
      if ((snapshotId != null) && snapshotId.hasOwnProperty('value')) {
        objectForSending[ServerContext.SNAPSHOT_ID] = snapshotId.value;
      } else {
        objectForSending[ServerContext.SNAPSHOT_ID] = snapshotId;
      }
      objectForSending[ServerContext.ISOLATION_LEVEL] = isolationLevel;
      objectForSending[ServerContext.TIMEOUT] = timeout._millis;
      return this.ServiceCall("OpenWorkspace", objectForSending, function(msg) {});
    };

    ServerContext.prototype.GetRootObjectId = function(snapshotId) {
      var objectForSending, rez;
      objectForSending = {};
      if ((snapshotId != null) && snapshotId.hasOwnProperty('value')) {
        objectForSending[ServerContext.SNAPSHOT_ID] = snapshotId.value;
      } else {
        objectForSending[ServerContext.SNAPSHOT_ID] = snapshotId;
      }
      rez = null;
      this.ServiceCall("GetRootObjectId", objectForSending, function(msg) {
        var temp;
        temp = msg.d;
        return rez = new Guid(JSON.parse(temp)[ServerContext.RESULT]);
      });
      return rez;
    };

    ServerContext.prototype.EnumerateNodes = function() {
      var rez;
      rez = null;
      this.ServiceCall("EnumerateNodes", null, function(msg) {
        var newObj, temp;
        temp = msg.d;
        newObj = JSON.parse(temp)[ServerContext.RESULT];
        return rez = ServerContext.ExtractType(newObj);
      });
      return rez;
    };

    ServerContext.prototype.Clear = function() {
      return this.ServiceCall("Clear", null, function(msg) {
        return alert("Clear");
      });
    };

    ServerContext.prototype.GetRootType = function() {
      var rez;
      rez = null;
      this.ServiceCall("GetRootType", null, function(msg) {
        var newObj, temp;
        temp = msg.d;
        newObj = JSON.parse(temp)[ServerContext.RESULT];
        return rez = ServerContext.ExtractType(newObj);
      });
      if (window.RootType === null) {
        window.RootType = rez;
      }
      return rez;
    };

    ServerContext.prototype.Contains = function(identifier) {
      var objectForSending, rez;
      rez = null;
      objectForSending = {};
      objectForSending[ServerContext.IDENTIFIER] = identifier.value;
      this.ServiceCall("Contains", objectForSending, function(msg) {
        var temp;
        temp = msg.d;
        return rez = new IOGBoolean(JSON.parse(temp)[ServerContext.RESULT]);
      });
      return rez;
    };

    ServerContext.prototype.GetNode = function(identifier, access) {
      var objectForSending, rez;
      rez = null;
      objectForSending = {};
      objectForSending[ServerContext.NODE_ID] = identifier.value;
      objectForSending[ServerContext.ACCESS] = access;
      this.ServiceCall("GetNode", objectForSending, function(msg) {
        var temp;
        temp = msg.d;
        return rez = ServerContext.NodeParser(JSON.parse(temp)[ServerContext.RESULT]);
      });
      return rez;
    };

    ServerContext.prototype.SetNode = function(identifier, node) {
      var objectForSending;
      objectForSending = {};
      objectForSending[ServerContext.IDENTIFIER] = identifier.value;
      objectForSending[ServerContext.NODE] = node;
      return this.ServiceCall("SetNode", objectForSending, function(msg) {});
    };

    ServerContext.prototype.ChangesBetween = function(oldSnapshotId, newSnapshotId) {
      var objectForSending, rez;
      rez = new Dictionary();
      objectForSending = {};
      objectForSending[ServerContext.NEW_SNAPSHOT_ID] = newSnapshotId;
      objectForSending[ServerContext.OLD_SNAPSHOT_ID] = oldSnapshotId;
      this.ServiceCall("ChangesBetween", objectForSending, function(msg) {
        var temp, tempRez;
        alert("ChangesBetween!");
        temp = msg.d;
        return tempRez = JSON.parse(temp)[ServerContext.RESULT];
      });
      return rez;
    };

    ServerContext.prototype.UpdateWorkspace = function(workspaceId, snapshotId) {
      var objectForSending;
      objectForSending = {};
      objectForSending[ServerContext.WORKSPACE_ID] = workspaceId;
      objectForSending[ServerContext.SNAPSHOT_ID] = snapshotId;
      return this.ServiceCall("UpdateWorkspace", objectForSending, function(msg) {
        return alert("UpdateWorkspace!");
      });
    };

    ServerContext.prototype.CloseWorkspace = function(workspaceId) {
      var objectForSending;
      objectForSending = {};
      objectForSending[ServerContext.WORKSPACE_ID] = workspaceId.value;
      return this.ServiceCall("CloseWorkspace", objectForSending, function(msg) {});
    };

    ServerContext.prototype.Commit = function(workspaceId, changeSet) {
      var objectForSending, rez;
      objectForSending = {};
      objectForSending[ServerContext.WORKSPACE_ID] = workspaceId.value;
      objectForSending[ServerContext.CHANGE_SET] = changeSet;
      rez = null;
      this.ServiceCall("Commit", objectForSending, function(msg) {
        var commitResult, key, mapping, resultSnapshotId, temp, tempRez, value, _ref;
        temp = msg.d;
        tempRez = JSON.parse(temp)[ServerContext.RESULT];
        if (tempRez.hasOwnProperty(ServerContext.MAPPING) && tempRez.hasOwnProperty(ServerContext.RESULT_SNAPSHOT_ID)) {
          resultSnapshotId = new Guid(tempRez[ServerContext.RESULT_SNAPSHOT_ID]);
          mapping = new Dictionary();
          _ref = tempRez[ServerContext.MAPPING];
          for (key in _ref) {
            value = _ref[key];
            if (typeof value !== 'function') {
              mapping.Add(new Guid(key), new Guid(value));
            }
          }
          commitResult = new CommitResult(resultSnapshotId, mapping);
          return rez = commitResult;
        }
      });
      return rez;
    };

    ServerContext.GetValue = function(object, property) {
      if (object.hasOwnProperty(property)) {
        return object[property];
      }
      return null;
    };

    ServerContext.ExtractGenericArguments = function(object) {
      var args, elem, rez, type, _i, _len;
      rez = [];
      args = this.GetValue(object, TypeConstants.GenericArguments);
      if ((args != null)) {
        if (args.length === 0) {
          try {
            type = IOGType.FindType(args.Name);
          } catch (error) {
            return rez;
          }
          if ((type != null)) {
            rez.push(type);
          }
        } else {
          for (_i = 0, _len = args.length; _i < _len; _i++) {
            elem = args[_i];
            try {
              type = IOGType.FindType(elem);
            } catch (error) {
              continue;
            }
            if ((type != null)) {
              rez.push(type);
            }
          }
        }
      }
      return rez;
    };

    ServerContext.ExtractType = function(object) {
      var customAttributes, enumValues, genericArguments, genericType, id, interfaces, isCollectionType, isDictionaryType, isEnum, isGenericType, isInterface, isScalar, name, objectProperties, properties, type;
      id = this.GetValue(object, TypeConstants.ID);
      name = this.GetValue(object, TypeConstants.Name);
      isCollectionType = this.GetValue(object, TypeConstants.IsCollectionType);
      isDictionaryType = this.GetValue(object, TypeConstants.IsDictionaryType);
      isInterface = this.GetValue(object, TypeConstants.IsInterface);
      isEnum = this.GetValue(object, TypeConstants.IsEnum);
      isGenericType = this.GetValue(object, TypeConstants.IsGenericType);
      customAttributes = this.GetValue(object, TypeConstants.CustomAttributes);
      interfaces = this.GetValue(object, TypeConstants.Interfaces);
      enumValues = this.GetValue(object, TypeConstants.EnumValues);
      genericArguments = ServerContext.ExtractGenericArguments(object);
      isScalar = this.GetValue(object, TypeConstants.IsScalar);
      genericType = this.GetValue(object, TypeConstants.GenericType);
      objectProperties = this.GetValue(object, TypeConstants.Properties);
      type = new IOGType(id, name, isCollectionType, isDictionaryType, isInterface, isEnum, isGenericType, genericType, customAttributes);
      if ((objectProperties != null) && !objectProperties.length <= 0) {
        properties = ServerContext.ExtractProperties(objectProperties, type);
      } else {
        properties = [];
      }
      type.properties = properties;
      type.interfaces = interfaces;
      type.enumValues = enumValues;
      type.genericArguments = genericArguments;
      type.isScalar = isScalar;
      return type;
    };

    ServerContext.ExtractProperties = function(object, decleringTypeParam) {
      var canRead, canWrite, customAttributes, decleringType, eleme, isStatic, name, pro, propertyType, result, tempDecleringType, tempProperty, _i, _len;
      if (decleringTypeParam == null) {
        decleringTypeParam = null;
      }
      result = [];
      for (_i = 0, _len = object.length; _i < _len; _i++) {
        eleme = object[_i];
        canRead = this.GetValue(eleme, ProperiteConstants.CanRead);
        canWrite = this.GetValue(eleme, ProperiteConstants.CanWrite);
        name = this.GetValue(eleme, ProperiteConstants.Name);
        isStatic = this.GetValue(eleme, ProperiteConstants.IsStatic);
        customAttributes = this.GetValue(eleme, ProperiteConstants.CustomAttributes);
        tempProperty = ServerContext.ExtractPropertyNameType(this.GetValue(eleme, ProperiteConstants.PropertyType));
        propertyType = tempProperty;
        tempDecleringType = ServerContext.ExtractPropertyNameType(this.GetValue(eleme, ProperiteConstants.DeclaringType));
        decleringType = tempDecleringType;
        pro = new PropertyInfo(canRead, canWrite, decleringType, name, propertyType, isStatic, customAttributes);
        result.push(pro);
      }
      return result;
    };

    ServerContext.ExtractPropertyNameType = function(object) {
      var genericArguments, nameOfType, propertyType;
      if (object === null) {
        return null;
      }
      if (!object.hasOwnProperty(ServerContext.NAME_OF_TYPE) || !object.hasOwnProperty(ServerContext.GENERIC_ARGUMENTS_TYPE_NAME)) {
        return null;
      }
      nameOfType = object[ServerContext.NAME_OF_TYPE];
      genericArguments = object[ServerContext.GENERIC_ARGUMENTS_TYPE_NAME];
      propertyType = new PropertyNameProxy(nameOfType, genericArguments);
      return propertyType;
    };

    ServerContext.NodeParser = function(object) {
      var dataObject, edgeDataKey, edgeValeu, edgesSortedList, element, key, newKey, node, value, valueParsed, valuesDictionary, _i, _len, _ref, _ref1;
      valuesDictionary = new Dictionary();
      _ref = object[ServerContext.VALUES];
      for (key in _ref) {
        if (!__hasProp.call(_ref, key)) continue;
        value = _ref[key];
        valueParsed = ServerContext.ObjectWrapperParse(value);
        newKey = new Guid(key);
        if (newKey.equals(Guid.EMPTY)) {
          continue;
        }
        valuesDictionary.Add(newKey, valueParsed);
      }
      edgesSortedList = new SortedList();
      _ref1 = object[ServerContext.EDGES];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        element = _ref1[_i];
        key = element[ServerContext.KEY];
        value = element[ServerContext.VALUE];
        edgeDataKey = ServerContext.EdgeDataParse(key);
        edgeValeu = ServerContext.EdgeParse(value);
        edgesSortedList.Add(edgeDataKey, edgeValeu);
      }
      dataObject = ServerContext.ObjectWrapperParse(object[ServerContext.DATA], object[ServerContext.NODE_TYPE]);
      node = new Node(object[ServerContext.NODE_TYPE], dataObject, edgesSortedList, valuesDictionary);
      node.previous = new Guid(object[ServerContext.PREVIOUS]);
      node.commited = object[ServerContext.COMMITED];
      return node;
    };

    ServerContext.EdgeParse = function(object) {
      var edge, unparsedEdge;
      if (!(object != null) || !(object.hasOwnProperty(ServerContext.TO_NODE_ID) && object.hasOwnProperty(ServerContext.DATA))) {
        return null;
      }
      unparsedEdge = new Guid(object[ServerContext.TO_NODE_ID]);
      edge = new Edge(unparsedEdge, ServerContext.EdgeDataParse(object[ServerContext.DATA]));
      return edge;
    };

    ServerContext.EdgeDataParse = function(object) {
      var edgeData;
      edgeData = new EdgeData();
      edgeData.semantic = object[ServerContext.SEMANTIC];
      edgeData.flags = object[ServerContext.FLAGS];
      edgeData.data = ServerContext.ObjectWrapperParse(object[ServerContext.DATA]);
      return edgeData;
    };

    ServerContext.ObjectWrapperParse = function(object, nodeType) {
      var tempRez;
      if (!(object != null) || !(object.hasOwnProperty(ServerContext.TYPE_NAME) && object.hasOwnProperty(ServerContext.DATA))) {
        return null;
      }
      if (!(object[ServerContext.TYPE_NAME] != null)) {
        return null;
      }
      if (nodeType === NodeType.Type) {
        return IOGType.FindType(object[ServerContext.TYPE_NAME]);
      }
      switch (object[ServerContext.TYPE_NAME]) {
        case ScalarName.String:
          tempRez = new IOGString(object[ServerContext.DATA]);
          return tempRez;
        case ScalarName.Guid:
          tempRez = new Guid(object[ServerContext.DATA]);
          return tempRez;
        case ScalarName.Int32:
          tempRez = new Int32(object[ServerContext.DATA]);
          return tempRez;
        case ScalarName.Int64:
          tempRez = new Int64(object[ServerContext.DATA]);
          return tempRez;
        case ScalarName.Double:
          tempRez = new Double(object[ServerContext.DATA]);
          return tempRez;
        case ScalarName.Boolean:
          tempRez = new IOGBoolean(object[ServerContext.DATA]);
          return tempRez;
        case ScalarName.Byte:
          tempRez = new Byte(object[ServerContext.DATA]);
          return tempRez;
        case ScalarName.Char:
          tempRez = new Char(object[ServerContext.DATA]);
          return tempRez;
        case ScalarName.DateTime:
          tempRez = ((new DateTime())._millis = object[ServerContext.DATA]);
          temmpRez[ServerContext.iogType] = object[window.DateTimeType];
          return tempRez;
        case ScalarName.TimeSpan:
          tempRez = ((new TimeSpanType())._millis = object[ServerContext.DATA]);
          temmpRez[ServerContext.iogType] = window.TimeSpanType;
          return tempRez;
        default:
          throw "Type is not supported!";
      }
    };

    return ServerContext;

  })();

  window.Workspace = (function() {

    function Workspace(snapshotId, timeout, nodeProvider, workspaceFacade, proxyCreatorService, typesService, isolationLevel, immutableProxyMap) {
      var isolatedStorage, rootObjectId, rootType;
      this.snapshotId = snapshotId;
      this.timeout = timeout;
      this.nodeProvider = nodeProvider;
      this.workspaceFacade = workspaceFacade;
      this.proxyCreatorService = proxyCreatorService;
      this.typesService = typesService;
      this.isolationLevel = isolationLevel;
      this.immutableProxyMap = immutableProxyMap;
      this.workspaceId = Guid.Create();
      this.mutableProxyMap = new LimitedProxyMap();
      this.workspaceFacade.OpenWorkspace(this.workspaceId, this.snapshotId, this.isolationLevel, this.timeout);
      if (this.isolationLevel === IsolationLevel.ReadOnly) {
        this.objectInstancesService = new ObjectInstancesService(this.nodeProvider, this.typesService);
        this.immutableInstancesService = new ObjectInstancesService(this.nodeProvider, this.typesService);
        this.collectionInstancesService = new CollectionInstancesService(this.nodeProvider, this.typesService);
        this.dictionaryInstancesService = new DictionaryInstancesService(this.nodeProvider, this.typesService);
      } else {
        isolatedStorage = new DirectNodeProvider(new MemoryStorage());
        this.isolatedProvider = new IsolatedNodeProvider(this.nodeProvider, isolatedStorage);
        this.objectInstancesService = new ObjectInstancesService(this.isolatedProvider, this.typesService);
        this.immutableInstancesService = new ObjectInstancesService(this.isolatedProvider, this.typesService);
        this.collectionInstancesService = new CollectionInstancesService(this.isolatedProvider, this.typesService);
        this.dictionaryInstancesService = new DictionaryInstancesService(this.isolatedProvider, this.typesService);
      }
      this.runtimeProxyFacade = new RuntimeProxyFacade(this.typesService, this.objectInstancesService, this.immutableInstancesService, this.collectionInstancesService, new CollectionInstancesService(this.nodeProvider, this.typesService), this.dictionaryInstancesService, new DictionaryInstancesService(this.nodeProvider, this.typesService), this.mutableProxyMap, immutableProxyMap, this.proxyCreatorService);
      rootObjectId = this.workspaceFacade.GetRootObjectId(snapshotId);
      rootType = this.workspaceFacade.GetRootType();
      this.rootProxy = proxyCreatorService.NewObject(this.runtimeProxyFacade, rootObjectId, isolationLevel === IsolationLevel.ReadOnly, rootType, null);
      if (this.isolationLevel === IsolationLevel.ReadOnly) {
        this.immutableProxyMap.AddProxy(rootObjectId, this.rootProxy);
      } else {
        this.mutableProxyMap.AddProxy(rootObjectId, this.rootProxy);
      }
    }

    Workspace.prototype.Data = function() {
      return this.rootProxy;
    };

    Workspace.prototype.SnapshotId = function() {
      return this.snapshotId;
    };

    Workspace.prototype.New = function(type, genericTypes) {
      var instanceId, proxy, typeId;
      if (genericTypes == null) {
        genericTypes = [];
      }
      typeId = this.typesService.GetTypeIdCached(type);
      if (typeId.equals(Guid.EMPTY)) {
        throw "Type not registered:" + type.name;
      }
      instanceId = Guid.EMPTY;
      if (this.typesService.IsDictionaryType(typeId)) {
        instanceId = this.dictionaryInstancesService.NewInstance(typeId);
      } else {
        if (this.typesService.IsCollectionType(typeId)) {
          instanceId = this.collectionInstancesService.NewInstance(typeId);
        } else {
          instanceId = this.objectInstancesService.NewInstance(typeId);
        }
      }
      proxy = this.proxyCreatorService.NewObject(this.runtimeProxyFacade, instanceId, false, type);
      this.mutableProxyMap.AddProxy(instanceId, proxy);
      return proxy;
    };

    Workspace.prototype.Spawn = function(revisionId) {
      throw "Revision is not implemented!";
    };

    Workspace.prototype.SpawnImmutable = function(revisionId, type) {
      throw "Revision is not implemented!";
    };

    Workspace.prototype.ImmutableView = function(instance, type) {
      var id, proxy, result;
      id = UTILS.GetItemId(instance);
      if (this.isolatedProvider.GetNodeState(id) === NodeState.Created) {
        throw "Operation not allowed for uncommited instance";
      }
      proxy = null;
      result = this.immutableProxyMap.TryGetProxy(id);
      if (!result["result"]) {
        proxy = proxyCreatorService.NewObject(runtimeProxyFacade, id, true, type);
        immutableProxyMap.AddProxy(id, proxy);
      }
      return proxy;
    };

    Workspace.prototype.InstanceRevisionId = function(instance) {
      return UTILS.GetItemId(instance);
    };

    Workspace.prototype.SetImmutable = function(instance, propertyName) {
      var instanceId;
      instanceId = UTILS.GetItemId(instance);
      this.objectInstancesService.SetImmutable(instanceId, this.typesService.GetTypeMemberId(this.typesService.GetInstanceTypeId(instanceId), propertyName));
    };

    Workspace.prototype.Commit = function() {
      var changeSet, isolatedChanges;
      if (this.isolationLevel === IsolationLevel.ReadOnly) {
        throw "Invalid commit operation in Read only isolation";
      }
      isolatedChanges = this.isolatedProvider.GetChanges(this.snapshotId);
      changeSet = this.workspaceFacade.Commit(this.workspaceId, isolatedChanges);
      this.mutableProxyMap.UpgradeProxies(changeSet.mapping);
      this.isolatedProvider.Clear();
      this.snapshotId = changeSet.resultSnapshotId;
      return this.snapshotId;
    };

    Workspace.prototype.Rollback = function() {
      var item, newInstances, _i, _len, _ref;
      if (this.isolationLevel === IsolationLevel.ReadOnly) {
        throw "Invalid rollback operation in Read only isolation";
      }
      newInstances = [];
      _ref = isolatedProvider.EnumerateChanges();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        item = _ref[_i];
        if (this.isolatedProvider.GetNodeState(item) === NodeState.Created) {
          newInstances.push(item);
        }
      }
      this.mutableProxyMap.InvalidateProxies(newInstances);
      return this.isolatedProvider.Clear();
    };

    Workspace.prototype.Update = function(newSnapshotId) {
      var changedNodeId, mapping, typeId, _i, _len, _ref;
      if ((newSnapshotId != null)) {
        mapping = this.workspaceFacade.ChangesBetween(this.snapshotId, newSnapshotId);
        if (isolatedProvider !== null) {
          _ref = isolatedProvider.EnumerateChanges();
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            changedNodeId = _ref[_i];
            if (mapping.Contains(changedNodeId)) {
              typeId = Guid.Empty;
              try {
                typeId = this.typesService.GetInstanceTypeId(changedNodeId);
              } catch (error) {
                throw "ConcurrentModificationException()";
              }
              throw "ConcurrentModificationException()";
            }
          }
        }
        this.mutableProxyMap.UpgradeProxies(mapping);
        this.snapshotId = newSnapshotId;
        this.workspaceFacade.UpdateWorkspace(this.workspaceId, this.snapshotId);
      } else {
        newSnapshotId = this.workspaceFacade.LastSnapshotId();
        return this.Update(newSnapshotId);
      }
    };

    Workspace.prototype.TryUpdate = function(newSnapshotId) {
      var changedNodeId, mapping, _i, _len, _ref;
      if (newSnapshotId == null) {
        newSnapshotId = null;
      }
      if ((newSnapshotId != null)) {
        mapping = this.workspaceFacade.ChangesBetween(snapshotId, newSnapshotId);
        if (this.isolatedProvider !== null) {
          _ref = isolatedProvider.EnumerateChanges();
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            changedNodeId = _ref[_i];
            if (mapping.Contains(changedNodeId)) {
              return false;
            }
          }
        }
        this.mutableProxyMap.UpgradeProxies(mapping);
        this.snapshotId = newSnapshotId;
        this.workspaceFacade.UpdateWorkspace(this.workspaceId, this.snapshotId);
        return true;
      } else {
        newSnapshotId = this.workspaceFacade.LastSnapshotId();
        return this.TryUpdate(newSnapshotId);
      }
    };

    Workspace.prototype.CreateSubscription = function(instance, del, notifyChangesFromSameWorkspace, propertyName) {
      throw "Not implemented";
    };

    Workspace.prototype.RemoveSubscription = function(subscription) {
      throw "Not implemented";
    };

    Workspace.prototype.SubWorkspace = function(del) {
      throw "Not implemented";
    };

    Workspace.prototype.CloseWorkspace = function() {
      this.workspaceFacade.CloseWorkspace(this.workspaceId);
      this.mutableProxyMap.InvalidateProxies();
      UTILS.SetItemId(this.rootProxy, Guid.EMPTY);
      return this.rootProxy = null;
    };

    return Workspace;

  })();

  window.ClientContext = (function() {
    var VALUE;

    VALUE = 'value';

    function ClientContext(hostname, serviceName, localStorage) {
      var tempDefaultWorkspaceTimeout, tempSnapshotIsolationEnabled;
      this.hostname = hostname;
      this.serviceName = serviceName;
      this.localStorage = localStorage != null ? localStorage : new DirectNodeProvider();
      this.snapshotIsolationEnabled = null;
      tempSnapshotIsolationEnabled = null;
      this.serverContext = new ServerContext(this.hostname, this.serviceName);
      /*@ServiceCall("SnapshotIsolationEnabled", null, (msg) ->
        alert("Snapshot isolation enabled!");
        temp = msg.d
        #TODO need to check if ther is result propertie
        tempSnapshotIsolationEnabled = JSON.parse(temp)[ClientContext.RESULT]
      )
      */

      this.snapshotIsolationEnabled = this.serverContext.SnapshotIsolationEnabled();
      this.defaultWorkspaceTimeout = null;
      tempDefaultWorkspaceTimeout = null;
      this.defaultWorkspaceTimeout = this.serverContext.DefaultWorkspaceTimeout();
      /*@ServiceCall("DefaultWorkspaceTimeout", null, (msg) ->
        alert("defaultWorkspaceTimeout!");
        temp = msg.d
        tempSpan = new TimeSpan()
        tempSpan._millis = JSON.parse(temp)[ClientContext.RESULT]
        #TODO need to check if ther is result propertie
        tempDefaultWorkspaceTimeout = tempSpan
      )
      */

      this.immutableProxyMap = new LimitedProxyMap(window.IOGSettings.ObjectCacheMinimumCount, window.IOGSettings.ObjectCacheMaximumCount);
      this.provider = new CachedReadNodeProvider(this.serverContext, this.localStorage);
      this.generationService = null;
      this.InitializeServices();
    }

    ClientContext.prototype.InitializeServices = function() {
      var completeTypesList, interfaceToGeneratedMapping, interfaceToTypeIdMapping;
      this.typesService = new TypesService(this.provider);
      window.types = [];
      this.serverContext.EntityTypes();
      /*@ServiceCall("EntityTypes", null, (msg) ->
        alert("EntityTypes!");
        temp = msg.d
        temp = JSON.parse(temp)
        for elem in temp
          newType = ClientContext.ExtractType(elem)
          window.types.push(newType)
          IOGType.FindScalar(newType)
      
      )
      */

      interfaceToTypeIdMapping = this.typesService.InitializeTypeSystem(window.types);
      completeTypesList = interfaceToTypeIdMapping.Keys();
      this.generationService = new GenerationService(this.typesService);
      interfaceToGeneratedMapping = this.generationService.GenerateProxyTypes(completeTypesList);
      this.proxyCreatorService = new ProxyCreatorService(completeTypesList, interfaceToTypeIdMapping, interfaceToGeneratedMapping);
      StaticProxyFacade.Initialize(this.typesService);
    };

    ClientContext.prototype.Backup = function(storage, snapshotId) {
      if (snapshotId == null) {
        snapshotId = "";
      }
      throw "Not implemented!";
    };

    ClientContext.prototype.Cleanup = function() {
      throw "Not implemented!";
    };

    ClientContext.prototype.ExpireWorkspaces = function() {
      throw "Not implemented!";
    };

    ClientContext.prototype.LastSnapshotId = function() {
      return this.serverContext.LastSnapshotId().value;
    };

    ClientContext.prototype.OpenWorkspace = function(isolationLevel, snapshotId, timeout) {
      var defaultSnapshotId, defaultWorkspaceTimeout, lastSnapshotId;
      if (snapshotId == null) {
        snapshotId = null;
      }
      if (timeout == null) {
        timeout = null;
      }
      defaultWorkspaceTimeout = null;
      defaultSnapshotId = null;
      if (!(snapshotId != null) && !(timeout != null)) {
        defaultWorkspaceTimeout = this.defaultWorkspaceTimeout;
        defaultSnapshotId = this.serverContext.LastSnapshotId();
      }
      if ((snapshotId != null) && !(timeout != null)) {
        if (!snapshotId.hasOwnProperty(ClientContext.VALUE)) {
          snapshotId = new Guid(snapshotId);
        }
        defaultSnapshotId = snapshotId;
        defaultWorkspaceTimeout = this.defaultWorkspaceTimeout;
      }
      if (!(snapshotId != null) && (timeout != null)) {
        defaultWorkspaceTimeout = timeout;
        if (!this.snapshotIsolationEnabled && isolationLevel === IsolationLevel.Snapshot) {
          throw "Snapshot isolation level disabled by configuration";
        }
        if (isolationLevel === IsolationLevel.Exclusive) {
          this.serverContext.EnterExclusiveLock();
        }
        snapshotId = this.serverContext.LastSnapshotId();
        return new Workspace(snapshotId, defaultWorkspaceTimeout, this.provider, this.serverContext, this.proxyCreatorService, this.typesService, isolationLevel, this.immutableProxyMap);
      }
      if (!this.snapshotIsolationEnabled && isolationLevel === IsolationLevel.Snapshot) {
        throw "Snapshot isolation level disabled by configuration";
      }
      if (isolationLevel === IsolationLevel.Exclusive) {
        this.serverContext.EnterExclusiveLock();
        lastSnapshotId = this.serverContext.LastSnapshotId();
        if (!defaultSnapshotId.equals(lastSnapshotId)) {
          throw "Snapshot other than the last snapshot cannot be opened for exclusive write.";
        } else {
          if (isolationLevel === IsolationLevel.Snapshot) {
            this.serverContext.EnterSharedLock();
          }
        }
      }
      return new Workspace(defaultSnapshotId, defaultWorkspaceTimeout, this.provider, this.serverContext, this.proxyCreatorService, this.typesService, isolationLevel, this.immutableProxyMap);
    };

    return ClientContext;

  })();

}).call(this);
