// Generated by CoffeeScript 1.3.3
(function() {

  module("B+ Tree");

  test("Test fill", function () {
    var iog = window.execom.iog;
    var TreeOrder, i, node, nodes, reference, references, rootId, _i, _j, _len, _results;
    nodes = new iog.DirectNodeProvider(new iog.MemoryStorage(), false);
    rootId = UUID.create();
    TreeOrder = 20;
    node = iog.BPlusTreeOperations.CreateRootNode(iog.NodeType.Collection, rootId);
    ok(node != null, "Root node created");
    ok(node.data === iog.BPlusTreeOperations.LeafNodeData, "Created node is Leaf");
    nodes.SetNode(rootId, node);
    references = [];
    for (i = _i = 0; _i <= 100; i = ++_i) {
      references.push(UUID.create());
    }
    _results = [];
    for (i = _j = 0, _len = references.length; _j < _len; i = ++_j) {
      reference = references[i];
      _results.push(iog.BPlusTreeOperations.InsertEdge(nodes, rootId, new iog.Edge(reference, new iog.EdgeData(iog.EdgeType.ListItem, reference)), TreeOrder));
    }
    return _results;
  });

  test("Test Consistency", function () {
    var iog = window.execom.iog;
    var TreeOrder, addedReference, data, dataAdded, i, j, node, nodes, reference, references, referencesAdded, rez, rootId, _i, _j, _k, _l, _len, _len1, _len2, _results;
    nodes = new iog.DirectNodeProvider(new iog.MemoryStorage(), false);
    rootId = UUID.create();
    node = iog.BPlusTreeOperations.CreateRootNode(iog.NodeType.Collection, rootId);
    nodes.SetNode(rootId, node);
    TreeOrder = 20;
    references = [];
    referencesAdded = [];
    for (i = _i = 0; _i <= 100; i = ++_i) {
      references.push(UUID.create());
    }
    for (j = _j = 0, _len = references.length; _j < _len; j = ++_j) {
      reference = references[j];
      data = new iog.EdgeData(iog.EdgeType.ListItem, reference);
      iog.BPlusTreeOperations.InsertEdge(nodes, rootId, new iog.Edge(reference, data), TreeOrder);
      referencesAdded.push(reference);
      for (i = _k = 0, _len1 = referencesAdded.length; _k < _len1; i = ++_k) {
        addedReference = referencesAdded[i];
        console.log("First for " + i + " time " + j);
        dataAdded = new iog.EdgeData(iog.EdgeType.ListItem, addedReference);
        rez = iog.BPlusTreeOperations.TryFindEdge(nodes, rootId, dataAdded);
        ok(rez.result === true, "Edge is found");
        ok(addedReference === rez.value.data.data, "Data found is expected");
      }
    }
    _results = [];
    for (i = _l = 0, _len2 = references.length; _l < _len2; i = ++_l) {
      reference = references[i];
      console.log("Second for " + i);
      data = new iog.EdgeData(iog.EdgeType.ListItem, reference);
      rez = iog.BPlusTreeOperations.TryFindEdge(nodes, rootId, data);
      ok(rez.result === true, "Edge is found");
      ok(reference === rez.value.data.data, "Data found is expected");
      _results.push(ok(reference === rez.value.toNodeId, "GUID found is expected"));
    }
    return _results;
  });

  test("Test Fill Remove", function() {
    var iog = window.execom.iog;
    var TreeOrder, count, i, node, nodes, numberOfElements, reference, references, rootId, _i, _j, _k, _len, _len1, _results;
    nodes = new iog.DirectNodeProvider(new iog.MemoryStorage(), false);
    TreeOrder = 20;
    rootId = UUID.create();
    node = iog.BPlusTreeOperations.CreateRootNode(iog.NodeType.Collection, rootId);
    nodes.SetNode(rootId, node);
    references = [];
    for (i = _i = 0; _i <= 100; i = ++_i) {
      references.push(UUID.create());
    }
    count = 0;
    for (_j = 0, _len = references.length; _j < _len; _j++) {
      reference = references[_j];
      ok(count === iog.BPlusTreeOperations.Count(nodes, rootId, iog.EdgeType.ListItem), "Count method is working for refrence " + reference);
      iog.BPlusTreeOperations.InsertEdge(nodes, rootId, new iog.Edge(reference, new iog.EdgeData(iog.EdgeType.ListItem, reference)), TreeOrder);
      count = count + 1;
    }
    _results = [];
    for (_k = 0, _len1 = references.length; _k < _len1; _k++) {
      reference = references[_k];
      numberOfElements = iog.BPlusTreeOperations.Count(nodes, rootId, iog.EdgeType.ListItem);
      ok(count === numberOfElements, "Count method after removing is working for refrence " + reference);
      iog.BPlusTreeOperations.RemoveEdge(nodes, rootId, new iog.EdgeData(iog.EdgeType.ListItem, reference), TreeOrder);
      _results.push(count = count - 1);
    }
    return _results;
  });

  test("Test Fill Remove Backwards", function() {
    var iog = window.execom.iog;
    var TreeOrder, count, i, node, nodes, numberOfElements, reference, references, rootId, _i, _j, _k, _len, _len1, _ref, _results;
    nodes = new iog.DirectNodeProvider(new iog.MemoryStorage(), false);
    TreeOrder = 20;
    rootId = UUID.create();
    node = iog.BPlusTreeOperations.CreateRootNode(iog.NodeType.Collection, rootId);
    nodes.SetNode(rootId, node);
    references = [];
    for (i = _i = 0; _i <= 100; i = ++_i) {
      references.push(UUID.create());
    }
    count = 0;
    for (_j = 0, _len = references.length; _j < _len; _j++) {
      reference = references[_j];
      ok(count === iog.BPlusTreeOperations.Count(nodes, rootId, iog.EdgeType.ListItem), "Count method is working for refrence " + reference);
      iog.BPlusTreeOperations.InsertEdge(nodes, rootId, new iog.Edge(reference, new iog.EdgeData(iog.EdgeType.ListItem, reference)), TreeOrder);
      count = count + 1;
    }
    _ref = references.reverse();
    _results = [];
    for (_k = 0, _len1 = _ref.length; _k < _len1; _k++) {
      reference = _ref[_k];
      numberOfElements = iog.BPlusTreeOperations.Count(nodes, rootId, iog.EdgeType.ListItem);
      ok(count === numberOfElements, "Count method after removing is working for refrence " + reference);
      iog.BPlusTreeOperations.RemoveEdge(nodes, rootId, new iog.EdgeData(iog.EdgeType.ListItem, reference), TreeOrder);
      _results.push(count = count - 1);
    }
    return _results;
  });

}).call(this);
